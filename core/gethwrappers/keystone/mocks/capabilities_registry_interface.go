// Code generated by mockery v2.45.0. DO NOT EDIT.

package mock_contracts

import (
	bind "github.com/ethereum/go-ethereum/accounts/abi/bind"
	common "github.com/ethereum/go-ethereum/common"
	capabilities_registry "github.com/smartcontractkit/chainlink/v2/core/gethwrappers/keystone/generated/capabilities_registry"

	event "github.com/ethereum/go-ethereum/event"

	generated "github.com/smartcontractkit/chainlink/v2/core/gethwrappers/generated"

	mock "github.com/stretchr/testify/mock"

	types "github.com/ethereum/go-ethereum/core/types"
)

// CapabilitiesRegistryInterface is an autogenerated mock type for the CapabilitiesRegistryInterface type
type CapabilitiesRegistryInterface struct {
	mock.Mock
}

type CapabilitiesRegistryInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *CapabilitiesRegistryInterface) EXPECT() *CapabilitiesRegistryInterface_Expecter {
	return &CapabilitiesRegistryInterface_Expecter{mock: &_m.Mock}
}

// AcceptOwnership provides a mock function with given fields: opts
func (_m *CapabilitiesRegistryInterface) AcceptOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for AcceptOwnership")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) (*types.Transaction, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_AcceptOwnership_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AcceptOwnership'
type CapabilitiesRegistryInterface_AcceptOwnership_Call struct {
	*mock.Call
}

// AcceptOwnership is a helper method to define mock.On call
//   - opts *bind.TransactOpts
func (_e *CapabilitiesRegistryInterface_Expecter) AcceptOwnership(opts interface{}) *CapabilitiesRegistryInterface_AcceptOwnership_Call {
	return &CapabilitiesRegistryInterface_AcceptOwnership_Call{Call: _e.mock.On("AcceptOwnership", opts)}
}

func (_c *CapabilitiesRegistryInterface_AcceptOwnership_Call) Run(run func(opts *bind.TransactOpts)) *CapabilitiesRegistryInterface_AcceptOwnership_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_AcceptOwnership_Call) Return(_a0 *types.Transaction, _a1 error) *CapabilitiesRegistryInterface_AcceptOwnership_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_AcceptOwnership_Call) RunAndReturn(run func(*bind.TransactOpts) (*types.Transaction, error)) *CapabilitiesRegistryInterface_AcceptOwnership_Call {
	_c.Call.Return(run)
	return _c
}

// AddCapabilities provides a mock function with given fields: opts, capabilities
func (_m *CapabilitiesRegistryInterface) AddCapabilities(opts *bind.TransactOpts, capabilities []capabilities_registry.CapabilitiesRegistryCapability) (*types.Transaction, error) {
	ret := _m.Called(opts, capabilities)

	if len(ret) == 0 {
		panic("no return value specified for AddCapabilities")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []capabilities_registry.CapabilitiesRegistryCapability) (*types.Transaction, error)); ok {
		return rf(opts, capabilities)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []capabilities_registry.CapabilitiesRegistryCapability) *types.Transaction); ok {
		r0 = rf(opts, capabilities)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []capabilities_registry.CapabilitiesRegistryCapability) error); ok {
		r1 = rf(opts, capabilities)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_AddCapabilities_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddCapabilities'
type CapabilitiesRegistryInterface_AddCapabilities_Call struct {
	*mock.Call
}

// AddCapabilities is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - capabilities []capabilities_registry.CapabilitiesRegistryCapability
func (_e *CapabilitiesRegistryInterface_Expecter) AddCapabilities(opts interface{}, capabilities interface{}) *CapabilitiesRegistryInterface_AddCapabilities_Call {
	return &CapabilitiesRegistryInterface_AddCapabilities_Call{Call: _e.mock.On("AddCapabilities", opts, capabilities)}
}

func (_c *CapabilitiesRegistryInterface_AddCapabilities_Call) Run(run func(opts *bind.TransactOpts, capabilities []capabilities_registry.CapabilitiesRegistryCapability)) *CapabilitiesRegistryInterface_AddCapabilities_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([]capabilities_registry.CapabilitiesRegistryCapability))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_AddCapabilities_Call) Return(_a0 *types.Transaction, _a1 error) *CapabilitiesRegistryInterface_AddCapabilities_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_AddCapabilities_Call) RunAndReturn(run func(*bind.TransactOpts, []capabilities_registry.CapabilitiesRegistryCapability) (*types.Transaction, error)) *CapabilitiesRegistryInterface_AddCapabilities_Call {
	_c.Call.Return(run)
	return _c
}

// AddDON provides a mock function with given fields: opts, nodes, capabilityConfigurations, isPublic, acceptsWorkflows, f
func (_m *CapabilitiesRegistryInterface) AddDON(opts *bind.TransactOpts, nodes [][32]byte, capabilityConfigurations []capabilities_registry.CapabilitiesRegistryCapabilityConfiguration, isPublic bool, acceptsWorkflows bool, f uint8) (*types.Transaction, error) {
	ret := _m.Called(opts, nodes, capabilityConfigurations, isPublic, acceptsWorkflows, f)

	if len(ret) == 0 {
		panic("no return value specified for AddDON")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [][32]byte, []capabilities_registry.CapabilitiesRegistryCapabilityConfiguration, bool, bool, uint8) (*types.Transaction, error)); ok {
		return rf(opts, nodes, capabilityConfigurations, isPublic, acceptsWorkflows, f)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [][32]byte, []capabilities_registry.CapabilitiesRegistryCapabilityConfiguration, bool, bool, uint8) *types.Transaction); ok {
		r0 = rf(opts, nodes, capabilityConfigurations, isPublic, acceptsWorkflows, f)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, [][32]byte, []capabilities_registry.CapabilitiesRegistryCapabilityConfiguration, bool, bool, uint8) error); ok {
		r1 = rf(opts, nodes, capabilityConfigurations, isPublic, acceptsWorkflows, f)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_AddDON_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddDON'
type CapabilitiesRegistryInterface_AddDON_Call struct {
	*mock.Call
}

// AddDON is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - nodes [][32]byte
//   - capabilityConfigurations []capabilities_registry.CapabilitiesRegistryCapabilityConfiguration
//   - isPublic bool
//   - acceptsWorkflows bool
//   - f uint8
func (_e *CapabilitiesRegistryInterface_Expecter) AddDON(opts interface{}, nodes interface{}, capabilityConfigurations interface{}, isPublic interface{}, acceptsWorkflows interface{}, f interface{}) *CapabilitiesRegistryInterface_AddDON_Call {
	return &CapabilitiesRegistryInterface_AddDON_Call{Call: _e.mock.On("AddDON", opts, nodes, capabilityConfigurations, isPublic, acceptsWorkflows, f)}
}

func (_c *CapabilitiesRegistryInterface_AddDON_Call) Run(run func(opts *bind.TransactOpts, nodes [][32]byte, capabilityConfigurations []capabilities_registry.CapabilitiesRegistryCapabilityConfiguration, isPublic bool, acceptsWorkflows bool, f uint8)) *CapabilitiesRegistryInterface_AddDON_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([][32]byte), args[2].([]capabilities_registry.CapabilitiesRegistryCapabilityConfiguration), args[3].(bool), args[4].(bool), args[5].(uint8))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_AddDON_Call) Return(_a0 *types.Transaction, _a1 error) *CapabilitiesRegistryInterface_AddDON_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_AddDON_Call) RunAndReturn(run func(*bind.TransactOpts, [][32]byte, []capabilities_registry.CapabilitiesRegistryCapabilityConfiguration, bool, bool, uint8) (*types.Transaction, error)) *CapabilitiesRegistryInterface_AddDON_Call {
	_c.Call.Return(run)
	return _c
}

// AddNodeOperators provides a mock function with given fields: opts, nodeOperators
func (_m *CapabilitiesRegistryInterface) AddNodeOperators(opts *bind.TransactOpts, nodeOperators []capabilities_registry.CapabilitiesRegistryNodeOperator) (*types.Transaction, error) {
	ret := _m.Called(opts, nodeOperators)

	if len(ret) == 0 {
		panic("no return value specified for AddNodeOperators")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []capabilities_registry.CapabilitiesRegistryNodeOperator) (*types.Transaction, error)); ok {
		return rf(opts, nodeOperators)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []capabilities_registry.CapabilitiesRegistryNodeOperator) *types.Transaction); ok {
		r0 = rf(opts, nodeOperators)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []capabilities_registry.CapabilitiesRegistryNodeOperator) error); ok {
		r1 = rf(opts, nodeOperators)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_AddNodeOperators_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddNodeOperators'
type CapabilitiesRegistryInterface_AddNodeOperators_Call struct {
	*mock.Call
}

// AddNodeOperators is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - nodeOperators []capabilities_registry.CapabilitiesRegistryNodeOperator
func (_e *CapabilitiesRegistryInterface_Expecter) AddNodeOperators(opts interface{}, nodeOperators interface{}) *CapabilitiesRegistryInterface_AddNodeOperators_Call {
	return &CapabilitiesRegistryInterface_AddNodeOperators_Call{Call: _e.mock.On("AddNodeOperators", opts, nodeOperators)}
}

func (_c *CapabilitiesRegistryInterface_AddNodeOperators_Call) Run(run func(opts *bind.TransactOpts, nodeOperators []capabilities_registry.CapabilitiesRegistryNodeOperator)) *CapabilitiesRegistryInterface_AddNodeOperators_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([]capabilities_registry.CapabilitiesRegistryNodeOperator))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_AddNodeOperators_Call) Return(_a0 *types.Transaction, _a1 error) *CapabilitiesRegistryInterface_AddNodeOperators_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_AddNodeOperators_Call) RunAndReturn(run func(*bind.TransactOpts, []capabilities_registry.CapabilitiesRegistryNodeOperator) (*types.Transaction, error)) *CapabilitiesRegistryInterface_AddNodeOperators_Call {
	_c.Call.Return(run)
	return _c
}

// AddNodes provides a mock function with given fields: opts, nodes
func (_m *CapabilitiesRegistryInterface) AddNodes(opts *bind.TransactOpts, nodes []capabilities_registry.CapabilitiesRegistryNodeParams) (*types.Transaction, error) {
	ret := _m.Called(opts, nodes)

	if len(ret) == 0 {
		panic("no return value specified for AddNodes")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []capabilities_registry.CapabilitiesRegistryNodeParams) (*types.Transaction, error)); ok {
		return rf(opts, nodes)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []capabilities_registry.CapabilitiesRegistryNodeParams) *types.Transaction); ok {
		r0 = rf(opts, nodes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []capabilities_registry.CapabilitiesRegistryNodeParams) error); ok {
		r1 = rf(opts, nodes)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_AddNodes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddNodes'
type CapabilitiesRegistryInterface_AddNodes_Call struct {
	*mock.Call
}

// AddNodes is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - nodes []capabilities_registry.CapabilitiesRegistryNodeParams
func (_e *CapabilitiesRegistryInterface_Expecter) AddNodes(opts interface{}, nodes interface{}) *CapabilitiesRegistryInterface_AddNodes_Call {
	return &CapabilitiesRegistryInterface_AddNodes_Call{Call: _e.mock.On("AddNodes", opts, nodes)}
}

func (_c *CapabilitiesRegistryInterface_AddNodes_Call) Run(run func(opts *bind.TransactOpts, nodes []capabilities_registry.CapabilitiesRegistryNodeParams)) *CapabilitiesRegistryInterface_AddNodes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([]capabilities_registry.CapabilitiesRegistryNodeParams))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_AddNodes_Call) Return(_a0 *types.Transaction, _a1 error) *CapabilitiesRegistryInterface_AddNodes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_AddNodes_Call) RunAndReturn(run func(*bind.TransactOpts, []capabilities_registry.CapabilitiesRegistryNodeParams) (*types.Transaction, error)) *CapabilitiesRegistryInterface_AddNodes_Call {
	_c.Call.Return(run)
	return _c
}

// Address provides a mock function with given fields:
func (_m *CapabilitiesRegistryInterface) Address() common.Address {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Address")
	}

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// CapabilitiesRegistryInterface_Address_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Address'
type CapabilitiesRegistryInterface_Address_Call struct {
	*mock.Call
}

// Address is a helper method to define mock.On call
func (_e *CapabilitiesRegistryInterface_Expecter) Address() *CapabilitiesRegistryInterface_Address_Call {
	return &CapabilitiesRegistryInterface_Address_Call{Call: _e.mock.On("Address")}
}

func (_c *CapabilitiesRegistryInterface_Address_Call) Run(run func()) *CapabilitiesRegistryInterface_Address_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_Address_Call) Return(_a0 common.Address) *CapabilitiesRegistryInterface_Address_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *CapabilitiesRegistryInterface_Address_Call) RunAndReturn(run func() common.Address) *CapabilitiesRegistryInterface_Address_Call {
	_c.Call.Return(run)
	return _c
}

// DeprecateCapabilities provides a mock function with given fields: opts, hashedCapabilityIds
func (_m *CapabilitiesRegistryInterface) DeprecateCapabilities(opts *bind.TransactOpts, hashedCapabilityIds [][32]byte) (*types.Transaction, error) {
	ret := _m.Called(opts, hashedCapabilityIds)

	if len(ret) == 0 {
		panic("no return value specified for DeprecateCapabilities")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [][32]byte) (*types.Transaction, error)); ok {
		return rf(opts, hashedCapabilityIds)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [][32]byte) *types.Transaction); ok {
		r0 = rf(opts, hashedCapabilityIds)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, [][32]byte) error); ok {
		r1 = rf(opts, hashedCapabilityIds)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_DeprecateCapabilities_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeprecateCapabilities'
type CapabilitiesRegistryInterface_DeprecateCapabilities_Call struct {
	*mock.Call
}

// DeprecateCapabilities is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - hashedCapabilityIds [][32]byte
func (_e *CapabilitiesRegistryInterface_Expecter) DeprecateCapabilities(opts interface{}, hashedCapabilityIds interface{}) *CapabilitiesRegistryInterface_DeprecateCapabilities_Call {
	return &CapabilitiesRegistryInterface_DeprecateCapabilities_Call{Call: _e.mock.On("DeprecateCapabilities", opts, hashedCapabilityIds)}
}

func (_c *CapabilitiesRegistryInterface_DeprecateCapabilities_Call) Run(run func(opts *bind.TransactOpts, hashedCapabilityIds [][32]byte)) *CapabilitiesRegistryInterface_DeprecateCapabilities_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([][32]byte))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_DeprecateCapabilities_Call) Return(_a0 *types.Transaction, _a1 error) *CapabilitiesRegistryInterface_DeprecateCapabilities_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_DeprecateCapabilities_Call) RunAndReturn(run func(*bind.TransactOpts, [][32]byte) (*types.Transaction, error)) *CapabilitiesRegistryInterface_DeprecateCapabilities_Call {
	_c.Call.Return(run)
	return _c
}

// FilterCapabilityConfigured provides a mock function with given fields: opts, hashedCapabilityId
func (_m *CapabilitiesRegistryInterface) FilterCapabilityConfigured(opts *bind.FilterOpts, hashedCapabilityId [][32]byte) (*capabilities_registry.CapabilitiesRegistryCapabilityConfiguredIterator, error) {
	ret := _m.Called(opts, hashedCapabilityId)

	if len(ret) == 0 {
		panic("no return value specified for FilterCapabilityConfigured")
	}

	var r0 *capabilities_registry.CapabilitiesRegistryCapabilityConfiguredIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte) (*capabilities_registry.CapabilitiesRegistryCapabilityConfiguredIterator, error)); ok {
		return rf(opts, hashedCapabilityId)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte) *capabilities_registry.CapabilitiesRegistryCapabilityConfiguredIterator); ok {
		r0 = rf(opts, hashedCapabilityId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*capabilities_registry.CapabilitiesRegistryCapabilityConfiguredIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, [][32]byte) error); ok {
		r1 = rf(opts, hashedCapabilityId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_FilterCapabilityConfigured_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterCapabilityConfigured'
type CapabilitiesRegistryInterface_FilterCapabilityConfigured_Call struct {
	*mock.Call
}

// FilterCapabilityConfigured is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - hashedCapabilityId [][32]byte
func (_e *CapabilitiesRegistryInterface_Expecter) FilterCapabilityConfigured(opts interface{}, hashedCapabilityId interface{}) *CapabilitiesRegistryInterface_FilterCapabilityConfigured_Call {
	return &CapabilitiesRegistryInterface_FilterCapabilityConfigured_Call{Call: _e.mock.On("FilterCapabilityConfigured", opts, hashedCapabilityId)}
}

func (_c *CapabilitiesRegistryInterface_FilterCapabilityConfigured_Call) Run(run func(opts *bind.FilterOpts, hashedCapabilityId [][32]byte)) *CapabilitiesRegistryInterface_FilterCapabilityConfigured_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([][32]byte))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_FilterCapabilityConfigured_Call) Return(_a0 *capabilities_registry.CapabilitiesRegistryCapabilityConfiguredIterator, _a1 error) *CapabilitiesRegistryInterface_FilterCapabilityConfigured_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_FilterCapabilityConfigured_Call) RunAndReturn(run func(*bind.FilterOpts, [][32]byte) (*capabilities_registry.CapabilitiesRegistryCapabilityConfiguredIterator, error)) *CapabilitiesRegistryInterface_FilterCapabilityConfigured_Call {
	_c.Call.Return(run)
	return _c
}

// FilterCapabilityDeprecated provides a mock function with given fields: opts, hashedCapabilityId
func (_m *CapabilitiesRegistryInterface) FilterCapabilityDeprecated(opts *bind.FilterOpts, hashedCapabilityId [][32]byte) (*capabilities_registry.CapabilitiesRegistryCapabilityDeprecatedIterator, error) {
	ret := _m.Called(opts, hashedCapabilityId)

	if len(ret) == 0 {
		panic("no return value specified for FilterCapabilityDeprecated")
	}

	var r0 *capabilities_registry.CapabilitiesRegistryCapabilityDeprecatedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte) (*capabilities_registry.CapabilitiesRegistryCapabilityDeprecatedIterator, error)); ok {
		return rf(opts, hashedCapabilityId)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte) *capabilities_registry.CapabilitiesRegistryCapabilityDeprecatedIterator); ok {
		r0 = rf(opts, hashedCapabilityId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*capabilities_registry.CapabilitiesRegistryCapabilityDeprecatedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, [][32]byte) error); ok {
		r1 = rf(opts, hashedCapabilityId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_FilterCapabilityDeprecated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterCapabilityDeprecated'
type CapabilitiesRegistryInterface_FilterCapabilityDeprecated_Call struct {
	*mock.Call
}

// FilterCapabilityDeprecated is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - hashedCapabilityId [][32]byte
func (_e *CapabilitiesRegistryInterface_Expecter) FilterCapabilityDeprecated(opts interface{}, hashedCapabilityId interface{}) *CapabilitiesRegistryInterface_FilterCapabilityDeprecated_Call {
	return &CapabilitiesRegistryInterface_FilterCapabilityDeprecated_Call{Call: _e.mock.On("FilterCapabilityDeprecated", opts, hashedCapabilityId)}
}

func (_c *CapabilitiesRegistryInterface_FilterCapabilityDeprecated_Call) Run(run func(opts *bind.FilterOpts, hashedCapabilityId [][32]byte)) *CapabilitiesRegistryInterface_FilterCapabilityDeprecated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([][32]byte))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_FilterCapabilityDeprecated_Call) Return(_a0 *capabilities_registry.CapabilitiesRegistryCapabilityDeprecatedIterator, _a1 error) *CapabilitiesRegistryInterface_FilterCapabilityDeprecated_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_FilterCapabilityDeprecated_Call) RunAndReturn(run func(*bind.FilterOpts, [][32]byte) (*capabilities_registry.CapabilitiesRegistryCapabilityDeprecatedIterator, error)) *CapabilitiesRegistryInterface_FilterCapabilityDeprecated_Call {
	_c.Call.Return(run)
	return _c
}

// FilterConfigSet provides a mock function with given fields: opts, donId
func (_m *CapabilitiesRegistryInterface) FilterConfigSet(opts *bind.FilterOpts, donId []uint32) (*capabilities_registry.CapabilitiesRegistryConfigSetIterator, error) {
	ret := _m.Called(opts, donId)

	if len(ret) == 0 {
		panic("no return value specified for FilterConfigSet")
	}

	var r0 *capabilities_registry.CapabilitiesRegistryConfigSetIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint32) (*capabilities_registry.CapabilitiesRegistryConfigSetIterator, error)); ok {
		return rf(opts, donId)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint32) *capabilities_registry.CapabilitiesRegistryConfigSetIterator); ok {
		r0 = rf(opts, donId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*capabilities_registry.CapabilitiesRegistryConfigSetIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []uint32) error); ok {
		r1 = rf(opts, donId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_FilterConfigSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterConfigSet'
type CapabilitiesRegistryInterface_FilterConfigSet_Call struct {
	*mock.Call
}

// FilterConfigSet is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - donId []uint32
func (_e *CapabilitiesRegistryInterface_Expecter) FilterConfigSet(opts interface{}, donId interface{}) *CapabilitiesRegistryInterface_FilterConfigSet_Call {
	return &CapabilitiesRegistryInterface_FilterConfigSet_Call{Call: _e.mock.On("FilterConfigSet", opts, donId)}
}

func (_c *CapabilitiesRegistryInterface_FilterConfigSet_Call) Run(run func(opts *bind.FilterOpts, donId []uint32)) *CapabilitiesRegistryInterface_FilterConfigSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([]uint32))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_FilterConfigSet_Call) Return(_a0 *capabilities_registry.CapabilitiesRegistryConfigSetIterator, _a1 error) *CapabilitiesRegistryInterface_FilterConfigSet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_FilterConfigSet_Call) RunAndReturn(run func(*bind.FilterOpts, []uint32) (*capabilities_registry.CapabilitiesRegistryConfigSetIterator, error)) *CapabilitiesRegistryInterface_FilterConfigSet_Call {
	_c.Call.Return(run)
	return _c
}

// FilterNodeAdded provides a mock function with given fields: opts, nodeOperatorId
func (_m *CapabilitiesRegistryInterface) FilterNodeAdded(opts *bind.FilterOpts, nodeOperatorId []uint32) (*capabilities_registry.CapabilitiesRegistryNodeAddedIterator, error) {
	ret := _m.Called(opts, nodeOperatorId)

	if len(ret) == 0 {
		panic("no return value specified for FilterNodeAdded")
	}

	var r0 *capabilities_registry.CapabilitiesRegistryNodeAddedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint32) (*capabilities_registry.CapabilitiesRegistryNodeAddedIterator, error)); ok {
		return rf(opts, nodeOperatorId)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint32) *capabilities_registry.CapabilitiesRegistryNodeAddedIterator); ok {
		r0 = rf(opts, nodeOperatorId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*capabilities_registry.CapabilitiesRegistryNodeAddedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []uint32) error); ok {
		r1 = rf(opts, nodeOperatorId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_FilterNodeAdded_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterNodeAdded'
type CapabilitiesRegistryInterface_FilterNodeAdded_Call struct {
	*mock.Call
}

// FilterNodeAdded is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - nodeOperatorId []uint32
func (_e *CapabilitiesRegistryInterface_Expecter) FilterNodeAdded(opts interface{}, nodeOperatorId interface{}) *CapabilitiesRegistryInterface_FilterNodeAdded_Call {
	return &CapabilitiesRegistryInterface_FilterNodeAdded_Call{Call: _e.mock.On("FilterNodeAdded", opts, nodeOperatorId)}
}

func (_c *CapabilitiesRegistryInterface_FilterNodeAdded_Call) Run(run func(opts *bind.FilterOpts, nodeOperatorId []uint32)) *CapabilitiesRegistryInterface_FilterNodeAdded_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([]uint32))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_FilterNodeAdded_Call) Return(_a0 *capabilities_registry.CapabilitiesRegistryNodeAddedIterator, _a1 error) *CapabilitiesRegistryInterface_FilterNodeAdded_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_FilterNodeAdded_Call) RunAndReturn(run func(*bind.FilterOpts, []uint32) (*capabilities_registry.CapabilitiesRegistryNodeAddedIterator, error)) *CapabilitiesRegistryInterface_FilterNodeAdded_Call {
	_c.Call.Return(run)
	return _c
}

// FilterNodeOperatorAdded provides a mock function with given fields: opts, nodeOperatorId, admin
func (_m *CapabilitiesRegistryInterface) FilterNodeOperatorAdded(opts *bind.FilterOpts, nodeOperatorId []uint32, admin []common.Address) (*capabilities_registry.CapabilitiesRegistryNodeOperatorAddedIterator, error) {
	ret := _m.Called(opts, nodeOperatorId, admin)

	if len(ret) == 0 {
		panic("no return value specified for FilterNodeOperatorAdded")
	}

	var r0 *capabilities_registry.CapabilitiesRegistryNodeOperatorAddedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint32, []common.Address) (*capabilities_registry.CapabilitiesRegistryNodeOperatorAddedIterator, error)); ok {
		return rf(opts, nodeOperatorId, admin)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint32, []common.Address) *capabilities_registry.CapabilitiesRegistryNodeOperatorAddedIterator); ok {
		r0 = rf(opts, nodeOperatorId, admin)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*capabilities_registry.CapabilitiesRegistryNodeOperatorAddedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []uint32, []common.Address) error); ok {
		r1 = rf(opts, nodeOperatorId, admin)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_FilterNodeOperatorAdded_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterNodeOperatorAdded'
type CapabilitiesRegistryInterface_FilterNodeOperatorAdded_Call struct {
	*mock.Call
}

// FilterNodeOperatorAdded is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - nodeOperatorId []uint32
//   - admin []common.Address
func (_e *CapabilitiesRegistryInterface_Expecter) FilterNodeOperatorAdded(opts interface{}, nodeOperatorId interface{}, admin interface{}) *CapabilitiesRegistryInterface_FilterNodeOperatorAdded_Call {
	return &CapabilitiesRegistryInterface_FilterNodeOperatorAdded_Call{Call: _e.mock.On("FilterNodeOperatorAdded", opts, nodeOperatorId, admin)}
}

func (_c *CapabilitiesRegistryInterface_FilterNodeOperatorAdded_Call) Run(run func(opts *bind.FilterOpts, nodeOperatorId []uint32, admin []common.Address)) *CapabilitiesRegistryInterface_FilterNodeOperatorAdded_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([]uint32), args[2].([]common.Address))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_FilterNodeOperatorAdded_Call) Return(_a0 *capabilities_registry.CapabilitiesRegistryNodeOperatorAddedIterator, _a1 error) *CapabilitiesRegistryInterface_FilterNodeOperatorAdded_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_FilterNodeOperatorAdded_Call) RunAndReturn(run func(*bind.FilterOpts, []uint32, []common.Address) (*capabilities_registry.CapabilitiesRegistryNodeOperatorAddedIterator, error)) *CapabilitiesRegistryInterface_FilterNodeOperatorAdded_Call {
	_c.Call.Return(run)
	return _c
}

// FilterNodeOperatorRemoved provides a mock function with given fields: opts, nodeOperatorId
func (_m *CapabilitiesRegistryInterface) FilterNodeOperatorRemoved(opts *bind.FilterOpts, nodeOperatorId []uint32) (*capabilities_registry.CapabilitiesRegistryNodeOperatorRemovedIterator, error) {
	ret := _m.Called(opts, nodeOperatorId)

	if len(ret) == 0 {
		panic("no return value specified for FilterNodeOperatorRemoved")
	}

	var r0 *capabilities_registry.CapabilitiesRegistryNodeOperatorRemovedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint32) (*capabilities_registry.CapabilitiesRegistryNodeOperatorRemovedIterator, error)); ok {
		return rf(opts, nodeOperatorId)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint32) *capabilities_registry.CapabilitiesRegistryNodeOperatorRemovedIterator); ok {
		r0 = rf(opts, nodeOperatorId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*capabilities_registry.CapabilitiesRegistryNodeOperatorRemovedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []uint32) error); ok {
		r1 = rf(opts, nodeOperatorId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_FilterNodeOperatorRemoved_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterNodeOperatorRemoved'
type CapabilitiesRegistryInterface_FilterNodeOperatorRemoved_Call struct {
	*mock.Call
}

// FilterNodeOperatorRemoved is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - nodeOperatorId []uint32
func (_e *CapabilitiesRegistryInterface_Expecter) FilterNodeOperatorRemoved(opts interface{}, nodeOperatorId interface{}) *CapabilitiesRegistryInterface_FilterNodeOperatorRemoved_Call {
	return &CapabilitiesRegistryInterface_FilterNodeOperatorRemoved_Call{Call: _e.mock.On("FilterNodeOperatorRemoved", opts, nodeOperatorId)}
}

func (_c *CapabilitiesRegistryInterface_FilterNodeOperatorRemoved_Call) Run(run func(opts *bind.FilterOpts, nodeOperatorId []uint32)) *CapabilitiesRegistryInterface_FilterNodeOperatorRemoved_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([]uint32))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_FilterNodeOperatorRemoved_Call) Return(_a0 *capabilities_registry.CapabilitiesRegistryNodeOperatorRemovedIterator, _a1 error) *CapabilitiesRegistryInterface_FilterNodeOperatorRemoved_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_FilterNodeOperatorRemoved_Call) RunAndReturn(run func(*bind.FilterOpts, []uint32) (*capabilities_registry.CapabilitiesRegistryNodeOperatorRemovedIterator, error)) *CapabilitiesRegistryInterface_FilterNodeOperatorRemoved_Call {
	_c.Call.Return(run)
	return _c
}

// FilterNodeOperatorUpdated provides a mock function with given fields: opts, nodeOperatorId, admin
func (_m *CapabilitiesRegistryInterface) FilterNodeOperatorUpdated(opts *bind.FilterOpts, nodeOperatorId []uint32, admin []common.Address) (*capabilities_registry.CapabilitiesRegistryNodeOperatorUpdatedIterator, error) {
	ret := _m.Called(opts, nodeOperatorId, admin)

	if len(ret) == 0 {
		panic("no return value specified for FilterNodeOperatorUpdated")
	}

	var r0 *capabilities_registry.CapabilitiesRegistryNodeOperatorUpdatedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint32, []common.Address) (*capabilities_registry.CapabilitiesRegistryNodeOperatorUpdatedIterator, error)); ok {
		return rf(opts, nodeOperatorId, admin)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint32, []common.Address) *capabilities_registry.CapabilitiesRegistryNodeOperatorUpdatedIterator); ok {
		r0 = rf(opts, nodeOperatorId, admin)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*capabilities_registry.CapabilitiesRegistryNodeOperatorUpdatedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []uint32, []common.Address) error); ok {
		r1 = rf(opts, nodeOperatorId, admin)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_FilterNodeOperatorUpdated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterNodeOperatorUpdated'
type CapabilitiesRegistryInterface_FilterNodeOperatorUpdated_Call struct {
	*mock.Call
}

// FilterNodeOperatorUpdated is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - nodeOperatorId []uint32
//   - admin []common.Address
func (_e *CapabilitiesRegistryInterface_Expecter) FilterNodeOperatorUpdated(opts interface{}, nodeOperatorId interface{}, admin interface{}) *CapabilitiesRegistryInterface_FilterNodeOperatorUpdated_Call {
	return &CapabilitiesRegistryInterface_FilterNodeOperatorUpdated_Call{Call: _e.mock.On("FilterNodeOperatorUpdated", opts, nodeOperatorId, admin)}
}

func (_c *CapabilitiesRegistryInterface_FilterNodeOperatorUpdated_Call) Run(run func(opts *bind.FilterOpts, nodeOperatorId []uint32, admin []common.Address)) *CapabilitiesRegistryInterface_FilterNodeOperatorUpdated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([]uint32), args[2].([]common.Address))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_FilterNodeOperatorUpdated_Call) Return(_a0 *capabilities_registry.CapabilitiesRegistryNodeOperatorUpdatedIterator, _a1 error) *CapabilitiesRegistryInterface_FilterNodeOperatorUpdated_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_FilterNodeOperatorUpdated_Call) RunAndReturn(run func(*bind.FilterOpts, []uint32, []common.Address) (*capabilities_registry.CapabilitiesRegistryNodeOperatorUpdatedIterator, error)) *CapabilitiesRegistryInterface_FilterNodeOperatorUpdated_Call {
	_c.Call.Return(run)
	return _c
}

// FilterNodeRemoved provides a mock function with given fields: opts
func (_m *CapabilitiesRegistryInterface) FilterNodeRemoved(opts *bind.FilterOpts) (*capabilities_registry.CapabilitiesRegistryNodeRemovedIterator, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for FilterNodeRemoved")
	}

	var r0 *capabilities_registry.CapabilitiesRegistryNodeRemovedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) (*capabilities_registry.CapabilitiesRegistryNodeRemovedIterator, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *capabilities_registry.CapabilitiesRegistryNodeRemovedIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*capabilities_registry.CapabilitiesRegistryNodeRemovedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_FilterNodeRemoved_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterNodeRemoved'
type CapabilitiesRegistryInterface_FilterNodeRemoved_Call struct {
	*mock.Call
}

// FilterNodeRemoved is a helper method to define mock.On call
//   - opts *bind.FilterOpts
func (_e *CapabilitiesRegistryInterface_Expecter) FilterNodeRemoved(opts interface{}) *CapabilitiesRegistryInterface_FilterNodeRemoved_Call {
	return &CapabilitiesRegistryInterface_FilterNodeRemoved_Call{Call: _e.mock.On("FilterNodeRemoved", opts)}
}

func (_c *CapabilitiesRegistryInterface_FilterNodeRemoved_Call) Run(run func(opts *bind.FilterOpts)) *CapabilitiesRegistryInterface_FilterNodeRemoved_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_FilterNodeRemoved_Call) Return(_a0 *capabilities_registry.CapabilitiesRegistryNodeRemovedIterator, _a1 error) *CapabilitiesRegistryInterface_FilterNodeRemoved_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_FilterNodeRemoved_Call) RunAndReturn(run func(*bind.FilterOpts) (*capabilities_registry.CapabilitiesRegistryNodeRemovedIterator, error)) *CapabilitiesRegistryInterface_FilterNodeRemoved_Call {
	_c.Call.Return(run)
	return _c
}

// FilterNodeUpdated provides a mock function with given fields: opts, nodeOperatorId
func (_m *CapabilitiesRegistryInterface) FilterNodeUpdated(opts *bind.FilterOpts, nodeOperatorId []uint32) (*capabilities_registry.CapabilitiesRegistryNodeUpdatedIterator, error) {
	ret := _m.Called(opts, nodeOperatorId)

	if len(ret) == 0 {
		panic("no return value specified for FilterNodeUpdated")
	}

	var r0 *capabilities_registry.CapabilitiesRegistryNodeUpdatedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint32) (*capabilities_registry.CapabilitiesRegistryNodeUpdatedIterator, error)); ok {
		return rf(opts, nodeOperatorId)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint32) *capabilities_registry.CapabilitiesRegistryNodeUpdatedIterator); ok {
		r0 = rf(opts, nodeOperatorId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*capabilities_registry.CapabilitiesRegistryNodeUpdatedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []uint32) error); ok {
		r1 = rf(opts, nodeOperatorId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_FilterNodeUpdated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterNodeUpdated'
type CapabilitiesRegistryInterface_FilterNodeUpdated_Call struct {
	*mock.Call
}

// FilterNodeUpdated is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - nodeOperatorId []uint32
func (_e *CapabilitiesRegistryInterface_Expecter) FilterNodeUpdated(opts interface{}, nodeOperatorId interface{}) *CapabilitiesRegistryInterface_FilterNodeUpdated_Call {
	return &CapabilitiesRegistryInterface_FilterNodeUpdated_Call{Call: _e.mock.On("FilterNodeUpdated", opts, nodeOperatorId)}
}

func (_c *CapabilitiesRegistryInterface_FilterNodeUpdated_Call) Run(run func(opts *bind.FilterOpts, nodeOperatorId []uint32)) *CapabilitiesRegistryInterface_FilterNodeUpdated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([]uint32))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_FilterNodeUpdated_Call) Return(_a0 *capabilities_registry.CapabilitiesRegistryNodeUpdatedIterator, _a1 error) *CapabilitiesRegistryInterface_FilterNodeUpdated_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_FilterNodeUpdated_Call) RunAndReturn(run func(*bind.FilterOpts, []uint32) (*capabilities_registry.CapabilitiesRegistryNodeUpdatedIterator, error)) *CapabilitiesRegistryInterface_FilterNodeUpdated_Call {
	_c.Call.Return(run)
	return _c
}

// FilterOwnershipTransferRequested provides a mock function with given fields: opts, from, to
func (_m *CapabilitiesRegistryInterface) FilterOwnershipTransferRequested(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*capabilities_registry.CapabilitiesRegistryOwnershipTransferRequestedIterator, error) {
	ret := _m.Called(opts, from, to)

	if len(ret) == 0 {
		panic("no return value specified for FilterOwnershipTransferRequested")
	}

	var r0 *capabilities_registry.CapabilitiesRegistryOwnershipTransferRequestedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) (*capabilities_registry.CapabilitiesRegistryOwnershipTransferRequestedIterator, error)); ok {
		return rf(opts, from, to)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) *capabilities_registry.CapabilitiesRegistryOwnershipTransferRequestedIterator); ok {
		r0 = rf(opts, from, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*capabilities_registry.CapabilitiesRegistryOwnershipTransferRequestedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, from, to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_FilterOwnershipTransferRequested_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterOwnershipTransferRequested'
type CapabilitiesRegistryInterface_FilterOwnershipTransferRequested_Call struct {
	*mock.Call
}

// FilterOwnershipTransferRequested is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - from []common.Address
//   - to []common.Address
func (_e *CapabilitiesRegistryInterface_Expecter) FilterOwnershipTransferRequested(opts interface{}, from interface{}, to interface{}) *CapabilitiesRegistryInterface_FilterOwnershipTransferRequested_Call {
	return &CapabilitiesRegistryInterface_FilterOwnershipTransferRequested_Call{Call: _e.mock.On("FilterOwnershipTransferRequested", opts, from, to)}
}

func (_c *CapabilitiesRegistryInterface_FilterOwnershipTransferRequested_Call) Run(run func(opts *bind.FilterOpts, from []common.Address, to []common.Address)) *CapabilitiesRegistryInterface_FilterOwnershipTransferRequested_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([]common.Address), args[2].([]common.Address))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_FilterOwnershipTransferRequested_Call) Return(_a0 *capabilities_registry.CapabilitiesRegistryOwnershipTransferRequestedIterator, _a1 error) *CapabilitiesRegistryInterface_FilterOwnershipTransferRequested_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_FilterOwnershipTransferRequested_Call) RunAndReturn(run func(*bind.FilterOpts, []common.Address, []common.Address) (*capabilities_registry.CapabilitiesRegistryOwnershipTransferRequestedIterator, error)) *CapabilitiesRegistryInterface_FilterOwnershipTransferRequested_Call {
	_c.Call.Return(run)
	return _c
}

// FilterOwnershipTransferred provides a mock function with given fields: opts, from, to
func (_m *CapabilitiesRegistryInterface) FilterOwnershipTransferred(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*capabilities_registry.CapabilitiesRegistryOwnershipTransferredIterator, error) {
	ret := _m.Called(opts, from, to)

	if len(ret) == 0 {
		panic("no return value specified for FilterOwnershipTransferred")
	}

	var r0 *capabilities_registry.CapabilitiesRegistryOwnershipTransferredIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) (*capabilities_registry.CapabilitiesRegistryOwnershipTransferredIterator, error)); ok {
		return rf(opts, from, to)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) *capabilities_registry.CapabilitiesRegistryOwnershipTransferredIterator); ok {
		r0 = rf(opts, from, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*capabilities_registry.CapabilitiesRegistryOwnershipTransferredIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, from, to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_FilterOwnershipTransferred_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterOwnershipTransferred'
type CapabilitiesRegistryInterface_FilterOwnershipTransferred_Call struct {
	*mock.Call
}

// FilterOwnershipTransferred is a helper method to define mock.On call
//   - opts *bind.FilterOpts
//   - from []common.Address
//   - to []common.Address
func (_e *CapabilitiesRegistryInterface_Expecter) FilterOwnershipTransferred(opts interface{}, from interface{}, to interface{}) *CapabilitiesRegistryInterface_FilterOwnershipTransferred_Call {
	return &CapabilitiesRegistryInterface_FilterOwnershipTransferred_Call{Call: _e.mock.On("FilterOwnershipTransferred", opts, from, to)}
}

func (_c *CapabilitiesRegistryInterface_FilterOwnershipTransferred_Call) Run(run func(opts *bind.FilterOpts, from []common.Address, to []common.Address)) *CapabilitiesRegistryInterface_FilterOwnershipTransferred_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.FilterOpts), args[1].([]common.Address), args[2].([]common.Address))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_FilterOwnershipTransferred_Call) Return(_a0 *capabilities_registry.CapabilitiesRegistryOwnershipTransferredIterator, _a1 error) *CapabilitiesRegistryInterface_FilterOwnershipTransferred_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_FilterOwnershipTransferred_Call) RunAndReturn(run func(*bind.FilterOpts, []common.Address, []common.Address) (*capabilities_registry.CapabilitiesRegistryOwnershipTransferredIterator, error)) *CapabilitiesRegistryInterface_FilterOwnershipTransferred_Call {
	_c.Call.Return(run)
	return _c
}

// GetCapabilities provides a mock function with given fields: opts
func (_m *CapabilitiesRegistryInterface) GetCapabilities(opts *bind.CallOpts) ([]capabilities_registry.CapabilitiesRegistryCapabilityInfo, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetCapabilities")
	}

	var r0 []capabilities_registry.CapabilitiesRegistryCapabilityInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) ([]capabilities_registry.CapabilitiesRegistryCapabilityInfo, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) []capabilities_registry.CapabilitiesRegistryCapabilityInfo); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]capabilities_registry.CapabilitiesRegistryCapabilityInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_GetCapabilities_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCapabilities'
type CapabilitiesRegistryInterface_GetCapabilities_Call struct {
	*mock.Call
}

// GetCapabilities is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *CapabilitiesRegistryInterface_Expecter) GetCapabilities(opts interface{}) *CapabilitiesRegistryInterface_GetCapabilities_Call {
	return &CapabilitiesRegistryInterface_GetCapabilities_Call{Call: _e.mock.On("GetCapabilities", opts)}
}

func (_c *CapabilitiesRegistryInterface_GetCapabilities_Call) Run(run func(opts *bind.CallOpts)) *CapabilitiesRegistryInterface_GetCapabilities_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_GetCapabilities_Call) Return(_a0 []capabilities_registry.CapabilitiesRegistryCapabilityInfo, _a1 error) *CapabilitiesRegistryInterface_GetCapabilities_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_GetCapabilities_Call) RunAndReturn(run func(*bind.CallOpts) ([]capabilities_registry.CapabilitiesRegistryCapabilityInfo, error)) *CapabilitiesRegistryInterface_GetCapabilities_Call {
	_c.Call.Return(run)
	return _c
}

// GetCapability provides a mock function with given fields: opts, hashedId
func (_m *CapabilitiesRegistryInterface) GetCapability(opts *bind.CallOpts, hashedId [32]byte) (capabilities_registry.CapabilitiesRegistryCapabilityInfo, error) {
	ret := _m.Called(opts, hashedId)

	if len(ret) == 0 {
		panic("no return value specified for GetCapability")
	}

	var r0 capabilities_registry.CapabilitiesRegistryCapabilityInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) (capabilities_registry.CapabilitiesRegistryCapabilityInfo, error)); ok {
		return rf(opts, hashedId)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) capabilities_registry.CapabilitiesRegistryCapabilityInfo); ok {
		r0 = rf(opts, hashedId)
	} else {
		r0 = ret.Get(0).(capabilities_registry.CapabilitiesRegistryCapabilityInfo)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, [32]byte) error); ok {
		r1 = rf(opts, hashedId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_GetCapability_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCapability'
type CapabilitiesRegistryInterface_GetCapability_Call struct {
	*mock.Call
}

// GetCapability is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - hashedId [32]byte
func (_e *CapabilitiesRegistryInterface_Expecter) GetCapability(opts interface{}, hashedId interface{}) *CapabilitiesRegistryInterface_GetCapability_Call {
	return &CapabilitiesRegistryInterface_GetCapability_Call{Call: _e.mock.On("GetCapability", opts, hashedId)}
}

func (_c *CapabilitiesRegistryInterface_GetCapability_Call) Run(run func(opts *bind.CallOpts, hashedId [32]byte)) *CapabilitiesRegistryInterface_GetCapability_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].([32]byte))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_GetCapability_Call) Return(_a0 capabilities_registry.CapabilitiesRegistryCapabilityInfo, _a1 error) *CapabilitiesRegistryInterface_GetCapability_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_GetCapability_Call) RunAndReturn(run func(*bind.CallOpts, [32]byte) (capabilities_registry.CapabilitiesRegistryCapabilityInfo, error)) *CapabilitiesRegistryInterface_GetCapability_Call {
	_c.Call.Return(run)
	return _c
}

// GetCapabilityConfigs provides a mock function with given fields: opts, donId, capabilityId
func (_m *CapabilitiesRegistryInterface) GetCapabilityConfigs(opts *bind.CallOpts, donId uint32, capabilityId [32]byte) ([]byte, []byte, error) {
	ret := _m.Called(opts, donId, capabilityId)

	if len(ret) == 0 {
		panic("no return value specified for GetCapabilityConfigs")
	}

	var r0 []byte
	var r1 []byte
	var r2 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint32, [32]byte) ([]byte, []byte, error)); ok {
		return rf(opts, donId, capabilityId)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint32, [32]byte) []byte); ok {
		r0 = rf(opts, donId, capabilityId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, uint32, [32]byte) []byte); ok {
		r1 = rf(opts, donId, capabilityId)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]byte)
		}
	}

	if rf, ok := ret.Get(2).(func(*bind.CallOpts, uint32, [32]byte) error); ok {
		r2 = rf(opts, donId, capabilityId)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// CapabilitiesRegistryInterface_GetCapabilityConfigs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCapabilityConfigs'
type CapabilitiesRegistryInterface_GetCapabilityConfigs_Call struct {
	*mock.Call
}

// GetCapabilityConfigs is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - donId uint32
//   - capabilityId [32]byte
func (_e *CapabilitiesRegistryInterface_Expecter) GetCapabilityConfigs(opts interface{}, donId interface{}, capabilityId interface{}) *CapabilitiesRegistryInterface_GetCapabilityConfigs_Call {
	return &CapabilitiesRegistryInterface_GetCapabilityConfigs_Call{Call: _e.mock.On("GetCapabilityConfigs", opts, donId, capabilityId)}
}

func (_c *CapabilitiesRegistryInterface_GetCapabilityConfigs_Call) Run(run func(opts *bind.CallOpts, donId uint32, capabilityId [32]byte)) *CapabilitiesRegistryInterface_GetCapabilityConfigs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].(uint32), args[2].([32]byte))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_GetCapabilityConfigs_Call) Return(_a0 []byte, _a1 []byte, _a2 error) *CapabilitiesRegistryInterface_GetCapabilityConfigs_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *CapabilitiesRegistryInterface_GetCapabilityConfigs_Call) RunAndReturn(run func(*bind.CallOpts, uint32, [32]byte) ([]byte, []byte, error)) *CapabilitiesRegistryInterface_GetCapabilityConfigs_Call {
	_c.Call.Return(run)
	return _c
}

// GetDON provides a mock function with given fields: opts, donId
func (_m *CapabilitiesRegistryInterface) GetDON(opts *bind.CallOpts, donId uint32) (capabilities_registry.CapabilitiesRegistryDONInfo, error) {
	ret := _m.Called(opts, donId)

	if len(ret) == 0 {
		panic("no return value specified for GetDON")
	}

	var r0 capabilities_registry.CapabilitiesRegistryDONInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint32) (capabilities_registry.CapabilitiesRegistryDONInfo, error)); ok {
		return rf(opts, donId)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint32) capabilities_registry.CapabilitiesRegistryDONInfo); ok {
		r0 = rf(opts, donId)
	} else {
		r0 = ret.Get(0).(capabilities_registry.CapabilitiesRegistryDONInfo)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, uint32) error); ok {
		r1 = rf(opts, donId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_GetDON_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDON'
type CapabilitiesRegistryInterface_GetDON_Call struct {
	*mock.Call
}

// GetDON is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - donId uint32
func (_e *CapabilitiesRegistryInterface_Expecter) GetDON(opts interface{}, donId interface{}) *CapabilitiesRegistryInterface_GetDON_Call {
	return &CapabilitiesRegistryInterface_GetDON_Call{Call: _e.mock.On("GetDON", opts, donId)}
}

func (_c *CapabilitiesRegistryInterface_GetDON_Call) Run(run func(opts *bind.CallOpts, donId uint32)) *CapabilitiesRegistryInterface_GetDON_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].(uint32))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_GetDON_Call) Return(_a0 capabilities_registry.CapabilitiesRegistryDONInfo, _a1 error) *CapabilitiesRegistryInterface_GetDON_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_GetDON_Call) RunAndReturn(run func(*bind.CallOpts, uint32) (capabilities_registry.CapabilitiesRegistryDONInfo, error)) *CapabilitiesRegistryInterface_GetDON_Call {
	_c.Call.Return(run)
	return _c
}

// GetDONs provides a mock function with given fields: opts
func (_m *CapabilitiesRegistryInterface) GetDONs(opts *bind.CallOpts) ([]capabilities_registry.CapabilitiesRegistryDONInfo, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetDONs")
	}

	var r0 []capabilities_registry.CapabilitiesRegistryDONInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) ([]capabilities_registry.CapabilitiesRegistryDONInfo, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) []capabilities_registry.CapabilitiesRegistryDONInfo); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]capabilities_registry.CapabilitiesRegistryDONInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_GetDONs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDONs'
type CapabilitiesRegistryInterface_GetDONs_Call struct {
	*mock.Call
}

// GetDONs is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *CapabilitiesRegistryInterface_Expecter) GetDONs(opts interface{}) *CapabilitiesRegistryInterface_GetDONs_Call {
	return &CapabilitiesRegistryInterface_GetDONs_Call{Call: _e.mock.On("GetDONs", opts)}
}

func (_c *CapabilitiesRegistryInterface_GetDONs_Call) Run(run func(opts *bind.CallOpts)) *CapabilitiesRegistryInterface_GetDONs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_GetDONs_Call) Return(_a0 []capabilities_registry.CapabilitiesRegistryDONInfo, _a1 error) *CapabilitiesRegistryInterface_GetDONs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_GetDONs_Call) RunAndReturn(run func(*bind.CallOpts) ([]capabilities_registry.CapabilitiesRegistryDONInfo, error)) *CapabilitiesRegistryInterface_GetDONs_Call {
	_c.Call.Return(run)
	return _c
}

// GetHashedCapabilityId provides a mock function with given fields: opts, labelledName, version
func (_m *CapabilitiesRegistryInterface) GetHashedCapabilityId(opts *bind.CallOpts, labelledName string, version string) ([32]byte, error) {
	ret := _m.Called(opts, labelledName, version)

	if len(ret) == 0 {
		panic("no return value specified for GetHashedCapabilityId")
	}

	var r0 [32]byte
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, string, string) ([32]byte, error)); ok {
		return rf(opts, labelledName, version)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, string, string) [32]byte); ok {
		r0 = rf(opts, labelledName, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([32]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, string, string) error); ok {
		r1 = rf(opts, labelledName, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_GetHashedCapabilityId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHashedCapabilityId'
type CapabilitiesRegistryInterface_GetHashedCapabilityId_Call struct {
	*mock.Call
}

// GetHashedCapabilityId is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - labelledName string
//   - version string
func (_e *CapabilitiesRegistryInterface_Expecter) GetHashedCapabilityId(opts interface{}, labelledName interface{}, version interface{}) *CapabilitiesRegistryInterface_GetHashedCapabilityId_Call {
	return &CapabilitiesRegistryInterface_GetHashedCapabilityId_Call{Call: _e.mock.On("GetHashedCapabilityId", opts, labelledName, version)}
}

func (_c *CapabilitiesRegistryInterface_GetHashedCapabilityId_Call) Run(run func(opts *bind.CallOpts, labelledName string, version string)) *CapabilitiesRegistryInterface_GetHashedCapabilityId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_GetHashedCapabilityId_Call) Return(_a0 [32]byte, _a1 error) *CapabilitiesRegistryInterface_GetHashedCapabilityId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_GetHashedCapabilityId_Call) RunAndReturn(run func(*bind.CallOpts, string, string) ([32]byte, error)) *CapabilitiesRegistryInterface_GetHashedCapabilityId_Call {
	_c.Call.Return(run)
	return _c
}

// GetNextDONId provides a mock function with given fields: opts
func (_m *CapabilitiesRegistryInterface) GetNextDONId(opts *bind.CallOpts) (uint32, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetNextDONId")
	}

	var r0 uint32
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (uint32, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint32); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_GetNextDONId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNextDONId'
type CapabilitiesRegistryInterface_GetNextDONId_Call struct {
	*mock.Call
}

// GetNextDONId is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *CapabilitiesRegistryInterface_Expecter) GetNextDONId(opts interface{}) *CapabilitiesRegistryInterface_GetNextDONId_Call {
	return &CapabilitiesRegistryInterface_GetNextDONId_Call{Call: _e.mock.On("GetNextDONId", opts)}
}

func (_c *CapabilitiesRegistryInterface_GetNextDONId_Call) Run(run func(opts *bind.CallOpts)) *CapabilitiesRegistryInterface_GetNextDONId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_GetNextDONId_Call) Return(_a0 uint32, _a1 error) *CapabilitiesRegistryInterface_GetNextDONId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_GetNextDONId_Call) RunAndReturn(run func(*bind.CallOpts) (uint32, error)) *CapabilitiesRegistryInterface_GetNextDONId_Call {
	_c.Call.Return(run)
	return _c
}

// GetNode provides a mock function with given fields: opts, p2pId
func (_m *CapabilitiesRegistryInterface) GetNode(opts *bind.CallOpts, p2pId [32]byte) (capabilities_registry.INodeInfoProviderNodeInfo, error) {
	ret := _m.Called(opts, p2pId)

	if len(ret) == 0 {
		panic("no return value specified for GetNode")
	}

	var r0 capabilities_registry.INodeInfoProviderNodeInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) (capabilities_registry.INodeInfoProviderNodeInfo, error)); ok {
		return rf(opts, p2pId)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) capabilities_registry.INodeInfoProviderNodeInfo); ok {
		r0 = rf(opts, p2pId)
	} else {
		r0 = ret.Get(0).(capabilities_registry.INodeInfoProviderNodeInfo)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, [32]byte) error); ok {
		r1 = rf(opts, p2pId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_GetNode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNode'
type CapabilitiesRegistryInterface_GetNode_Call struct {
	*mock.Call
}

// GetNode is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - p2pId [32]byte
func (_e *CapabilitiesRegistryInterface_Expecter) GetNode(opts interface{}, p2pId interface{}) *CapabilitiesRegistryInterface_GetNode_Call {
	return &CapabilitiesRegistryInterface_GetNode_Call{Call: _e.mock.On("GetNode", opts, p2pId)}
}

func (_c *CapabilitiesRegistryInterface_GetNode_Call) Run(run func(opts *bind.CallOpts, p2pId [32]byte)) *CapabilitiesRegistryInterface_GetNode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].([32]byte))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_GetNode_Call) Return(_a0 capabilities_registry.INodeInfoProviderNodeInfo, _a1 error) *CapabilitiesRegistryInterface_GetNode_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_GetNode_Call) RunAndReturn(run func(*bind.CallOpts, [32]byte) (capabilities_registry.INodeInfoProviderNodeInfo, error)) *CapabilitiesRegistryInterface_GetNode_Call {
	_c.Call.Return(run)
	return _c
}

// GetNodeOperator provides a mock function with given fields: opts, nodeOperatorId
func (_m *CapabilitiesRegistryInterface) GetNodeOperator(opts *bind.CallOpts, nodeOperatorId uint32) (capabilities_registry.CapabilitiesRegistryNodeOperator, error) {
	ret := _m.Called(opts, nodeOperatorId)

	if len(ret) == 0 {
		panic("no return value specified for GetNodeOperator")
	}

	var r0 capabilities_registry.CapabilitiesRegistryNodeOperator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint32) (capabilities_registry.CapabilitiesRegistryNodeOperator, error)); ok {
		return rf(opts, nodeOperatorId)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint32) capabilities_registry.CapabilitiesRegistryNodeOperator); ok {
		r0 = rf(opts, nodeOperatorId)
	} else {
		r0 = ret.Get(0).(capabilities_registry.CapabilitiesRegistryNodeOperator)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, uint32) error); ok {
		r1 = rf(opts, nodeOperatorId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_GetNodeOperator_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNodeOperator'
type CapabilitiesRegistryInterface_GetNodeOperator_Call struct {
	*mock.Call
}

// GetNodeOperator is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - nodeOperatorId uint32
func (_e *CapabilitiesRegistryInterface_Expecter) GetNodeOperator(opts interface{}, nodeOperatorId interface{}) *CapabilitiesRegistryInterface_GetNodeOperator_Call {
	return &CapabilitiesRegistryInterface_GetNodeOperator_Call{Call: _e.mock.On("GetNodeOperator", opts, nodeOperatorId)}
}

func (_c *CapabilitiesRegistryInterface_GetNodeOperator_Call) Run(run func(opts *bind.CallOpts, nodeOperatorId uint32)) *CapabilitiesRegistryInterface_GetNodeOperator_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].(uint32))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_GetNodeOperator_Call) Return(_a0 capabilities_registry.CapabilitiesRegistryNodeOperator, _a1 error) *CapabilitiesRegistryInterface_GetNodeOperator_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_GetNodeOperator_Call) RunAndReturn(run func(*bind.CallOpts, uint32) (capabilities_registry.CapabilitiesRegistryNodeOperator, error)) *CapabilitiesRegistryInterface_GetNodeOperator_Call {
	_c.Call.Return(run)
	return _c
}

// GetNodeOperators provides a mock function with given fields: opts
func (_m *CapabilitiesRegistryInterface) GetNodeOperators(opts *bind.CallOpts) ([]capabilities_registry.CapabilitiesRegistryNodeOperator, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetNodeOperators")
	}

	var r0 []capabilities_registry.CapabilitiesRegistryNodeOperator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) ([]capabilities_registry.CapabilitiesRegistryNodeOperator, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) []capabilities_registry.CapabilitiesRegistryNodeOperator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]capabilities_registry.CapabilitiesRegistryNodeOperator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_GetNodeOperators_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNodeOperators'
type CapabilitiesRegistryInterface_GetNodeOperators_Call struct {
	*mock.Call
}

// GetNodeOperators is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *CapabilitiesRegistryInterface_Expecter) GetNodeOperators(opts interface{}) *CapabilitiesRegistryInterface_GetNodeOperators_Call {
	return &CapabilitiesRegistryInterface_GetNodeOperators_Call{Call: _e.mock.On("GetNodeOperators", opts)}
}

func (_c *CapabilitiesRegistryInterface_GetNodeOperators_Call) Run(run func(opts *bind.CallOpts)) *CapabilitiesRegistryInterface_GetNodeOperators_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_GetNodeOperators_Call) Return(_a0 []capabilities_registry.CapabilitiesRegistryNodeOperator, _a1 error) *CapabilitiesRegistryInterface_GetNodeOperators_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_GetNodeOperators_Call) RunAndReturn(run func(*bind.CallOpts) ([]capabilities_registry.CapabilitiesRegistryNodeOperator, error)) *CapabilitiesRegistryInterface_GetNodeOperators_Call {
	_c.Call.Return(run)
	return _c
}

// GetNodes provides a mock function with given fields: opts
func (_m *CapabilitiesRegistryInterface) GetNodes(opts *bind.CallOpts) ([]capabilities_registry.INodeInfoProviderNodeInfo, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetNodes")
	}

	var r0 []capabilities_registry.INodeInfoProviderNodeInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) ([]capabilities_registry.INodeInfoProviderNodeInfo, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) []capabilities_registry.INodeInfoProviderNodeInfo); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]capabilities_registry.INodeInfoProviderNodeInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_GetNodes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNodes'
type CapabilitiesRegistryInterface_GetNodes_Call struct {
	*mock.Call
}

// GetNodes is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *CapabilitiesRegistryInterface_Expecter) GetNodes(opts interface{}) *CapabilitiesRegistryInterface_GetNodes_Call {
	return &CapabilitiesRegistryInterface_GetNodes_Call{Call: _e.mock.On("GetNodes", opts)}
}

func (_c *CapabilitiesRegistryInterface_GetNodes_Call) Run(run func(opts *bind.CallOpts)) *CapabilitiesRegistryInterface_GetNodes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_GetNodes_Call) Return(_a0 []capabilities_registry.INodeInfoProviderNodeInfo, _a1 error) *CapabilitiesRegistryInterface_GetNodes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_GetNodes_Call) RunAndReturn(run func(*bind.CallOpts) ([]capabilities_registry.INodeInfoProviderNodeInfo, error)) *CapabilitiesRegistryInterface_GetNodes_Call {
	_c.Call.Return(run)
	return _c
}

// GetNodesByP2PIds provides a mock function with given fields: opts, p2pIds
func (_m *CapabilitiesRegistryInterface) GetNodesByP2PIds(opts *bind.CallOpts, p2pIds [][32]byte) ([]capabilities_registry.INodeInfoProviderNodeInfo, error) {
	ret := _m.Called(opts, p2pIds)

	if len(ret) == 0 {
		panic("no return value specified for GetNodesByP2PIds")
	}

	var r0 []capabilities_registry.INodeInfoProviderNodeInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [][32]byte) ([]capabilities_registry.INodeInfoProviderNodeInfo, error)); ok {
		return rf(opts, p2pIds)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [][32]byte) []capabilities_registry.INodeInfoProviderNodeInfo); ok {
		r0 = rf(opts, p2pIds)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]capabilities_registry.INodeInfoProviderNodeInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, [][32]byte) error); ok {
		r1 = rf(opts, p2pIds)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_GetNodesByP2PIds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNodesByP2PIds'
type CapabilitiesRegistryInterface_GetNodesByP2PIds_Call struct {
	*mock.Call
}

// GetNodesByP2PIds is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - p2pIds [][32]byte
func (_e *CapabilitiesRegistryInterface_Expecter) GetNodesByP2PIds(opts interface{}, p2pIds interface{}) *CapabilitiesRegistryInterface_GetNodesByP2PIds_Call {
	return &CapabilitiesRegistryInterface_GetNodesByP2PIds_Call{Call: _e.mock.On("GetNodesByP2PIds", opts, p2pIds)}
}

func (_c *CapabilitiesRegistryInterface_GetNodesByP2PIds_Call) Run(run func(opts *bind.CallOpts, p2pIds [][32]byte)) *CapabilitiesRegistryInterface_GetNodesByP2PIds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].([][32]byte))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_GetNodesByP2PIds_Call) Return(_a0 []capabilities_registry.INodeInfoProviderNodeInfo, _a1 error) *CapabilitiesRegistryInterface_GetNodesByP2PIds_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_GetNodesByP2PIds_Call) RunAndReturn(run func(*bind.CallOpts, [][32]byte) ([]capabilities_registry.INodeInfoProviderNodeInfo, error)) *CapabilitiesRegistryInterface_GetNodesByP2PIds_Call {
	_c.Call.Return(run)
	return _c
}

// IsCapabilityDeprecated provides a mock function with given fields: opts, hashedCapabilityId
func (_m *CapabilitiesRegistryInterface) IsCapabilityDeprecated(opts *bind.CallOpts, hashedCapabilityId [32]byte) (bool, error) {
	ret := _m.Called(opts, hashedCapabilityId)

	if len(ret) == 0 {
		panic("no return value specified for IsCapabilityDeprecated")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) (bool, error)); ok {
		return rf(opts, hashedCapabilityId)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) bool); ok {
		r0 = rf(opts, hashedCapabilityId)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, [32]byte) error); ok {
		r1 = rf(opts, hashedCapabilityId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_IsCapabilityDeprecated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsCapabilityDeprecated'
type CapabilitiesRegistryInterface_IsCapabilityDeprecated_Call struct {
	*mock.Call
}

// IsCapabilityDeprecated is a helper method to define mock.On call
//   - opts *bind.CallOpts
//   - hashedCapabilityId [32]byte
func (_e *CapabilitiesRegistryInterface_Expecter) IsCapabilityDeprecated(opts interface{}, hashedCapabilityId interface{}) *CapabilitiesRegistryInterface_IsCapabilityDeprecated_Call {
	return &CapabilitiesRegistryInterface_IsCapabilityDeprecated_Call{Call: _e.mock.On("IsCapabilityDeprecated", opts, hashedCapabilityId)}
}

func (_c *CapabilitiesRegistryInterface_IsCapabilityDeprecated_Call) Run(run func(opts *bind.CallOpts, hashedCapabilityId [32]byte)) *CapabilitiesRegistryInterface_IsCapabilityDeprecated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts), args[1].([32]byte))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_IsCapabilityDeprecated_Call) Return(_a0 bool, _a1 error) *CapabilitiesRegistryInterface_IsCapabilityDeprecated_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_IsCapabilityDeprecated_Call) RunAndReturn(run func(*bind.CallOpts, [32]byte) (bool, error)) *CapabilitiesRegistryInterface_IsCapabilityDeprecated_Call {
	_c.Call.Return(run)
	return _c
}

// Owner provides a mock function with given fields: opts
func (_m *CapabilitiesRegistryInterface) Owner(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for Owner")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (common.Address, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_Owner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Owner'
type CapabilitiesRegistryInterface_Owner_Call struct {
	*mock.Call
}

// Owner is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *CapabilitiesRegistryInterface_Expecter) Owner(opts interface{}) *CapabilitiesRegistryInterface_Owner_Call {
	return &CapabilitiesRegistryInterface_Owner_Call{Call: _e.mock.On("Owner", opts)}
}

func (_c *CapabilitiesRegistryInterface_Owner_Call) Run(run func(opts *bind.CallOpts)) *CapabilitiesRegistryInterface_Owner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_Owner_Call) Return(_a0 common.Address, _a1 error) *CapabilitiesRegistryInterface_Owner_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_Owner_Call) RunAndReturn(run func(*bind.CallOpts) (common.Address, error)) *CapabilitiesRegistryInterface_Owner_Call {
	_c.Call.Return(run)
	return _c
}

// ParseCapabilityConfigured provides a mock function with given fields: log
func (_m *CapabilitiesRegistryInterface) ParseCapabilityConfigured(log types.Log) (*capabilities_registry.CapabilitiesRegistryCapabilityConfigured, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseCapabilityConfigured")
	}

	var r0 *capabilities_registry.CapabilitiesRegistryCapabilityConfigured
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*capabilities_registry.CapabilitiesRegistryCapabilityConfigured, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *capabilities_registry.CapabilitiesRegistryCapabilityConfigured); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*capabilities_registry.CapabilitiesRegistryCapabilityConfigured)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_ParseCapabilityConfigured_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseCapabilityConfigured'
type CapabilitiesRegistryInterface_ParseCapabilityConfigured_Call struct {
	*mock.Call
}

// ParseCapabilityConfigured is a helper method to define mock.On call
//   - log types.Log
func (_e *CapabilitiesRegistryInterface_Expecter) ParseCapabilityConfigured(log interface{}) *CapabilitiesRegistryInterface_ParseCapabilityConfigured_Call {
	return &CapabilitiesRegistryInterface_ParseCapabilityConfigured_Call{Call: _e.mock.On("ParseCapabilityConfigured", log)}
}

func (_c *CapabilitiesRegistryInterface_ParseCapabilityConfigured_Call) Run(run func(log types.Log)) *CapabilitiesRegistryInterface_ParseCapabilityConfigured_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_ParseCapabilityConfigured_Call) Return(_a0 *capabilities_registry.CapabilitiesRegistryCapabilityConfigured, _a1 error) *CapabilitiesRegistryInterface_ParseCapabilityConfigured_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_ParseCapabilityConfigured_Call) RunAndReturn(run func(types.Log) (*capabilities_registry.CapabilitiesRegistryCapabilityConfigured, error)) *CapabilitiesRegistryInterface_ParseCapabilityConfigured_Call {
	_c.Call.Return(run)
	return _c
}

// ParseCapabilityDeprecated provides a mock function with given fields: log
func (_m *CapabilitiesRegistryInterface) ParseCapabilityDeprecated(log types.Log) (*capabilities_registry.CapabilitiesRegistryCapabilityDeprecated, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseCapabilityDeprecated")
	}

	var r0 *capabilities_registry.CapabilitiesRegistryCapabilityDeprecated
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*capabilities_registry.CapabilitiesRegistryCapabilityDeprecated, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *capabilities_registry.CapabilitiesRegistryCapabilityDeprecated); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*capabilities_registry.CapabilitiesRegistryCapabilityDeprecated)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_ParseCapabilityDeprecated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseCapabilityDeprecated'
type CapabilitiesRegistryInterface_ParseCapabilityDeprecated_Call struct {
	*mock.Call
}

// ParseCapabilityDeprecated is a helper method to define mock.On call
//   - log types.Log
func (_e *CapabilitiesRegistryInterface_Expecter) ParseCapabilityDeprecated(log interface{}) *CapabilitiesRegistryInterface_ParseCapabilityDeprecated_Call {
	return &CapabilitiesRegistryInterface_ParseCapabilityDeprecated_Call{Call: _e.mock.On("ParseCapabilityDeprecated", log)}
}

func (_c *CapabilitiesRegistryInterface_ParseCapabilityDeprecated_Call) Run(run func(log types.Log)) *CapabilitiesRegistryInterface_ParseCapabilityDeprecated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_ParseCapabilityDeprecated_Call) Return(_a0 *capabilities_registry.CapabilitiesRegistryCapabilityDeprecated, _a1 error) *CapabilitiesRegistryInterface_ParseCapabilityDeprecated_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_ParseCapabilityDeprecated_Call) RunAndReturn(run func(types.Log) (*capabilities_registry.CapabilitiesRegistryCapabilityDeprecated, error)) *CapabilitiesRegistryInterface_ParseCapabilityDeprecated_Call {
	_c.Call.Return(run)
	return _c
}

// ParseConfigSet provides a mock function with given fields: log
func (_m *CapabilitiesRegistryInterface) ParseConfigSet(log types.Log) (*capabilities_registry.CapabilitiesRegistryConfigSet, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseConfigSet")
	}

	var r0 *capabilities_registry.CapabilitiesRegistryConfigSet
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*capabilities_registry.CapabilitiesRegistryConfigSet, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *capabilities_registry.CapabilitiesRegistryConfigSet); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*capabilities_registry.CapabilitiesRegistryConfigSet)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_ParseConfigSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseConfigSet'
type CapabilitiesRegistryInterface_ParseConfigSet_Call struct {
	*mock.Call
}

// ParseConfigSet is a helper method to define mock.On call
//   - log types.Log
func (_e *CapabilitiesRegistryInterface_Expecter) ParseConfigSet(log interface{}) *CapabilitiesRegistryInterface_ParseConfigSet_Call {
	return &CapabilitiesRegistryInterface_ParseConfigSet_Call{Call: _e.mock.On("ParseConfigSet", log)}
}

func (_c *CapabilitiesRegistryInterface_ParseConfigSet_Call) Run(run func(log types.Log)) *CapabilitiesRegistryInterface_ParseConfigSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_ParseConfigSet_Call) Return(_a0 *capabilities_registry.CapabilitiesRegistryConfigSet, _a1 error) *CapabilitiesRegistryInterface_ParseConfigSet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_ParseConfigSet_Call) RunAndReturn(run func(types.Log) (*capabilities_registry.CapabilitiesRegistryConfigSet, error)) *CapabilitiesRegistryInterface_ParseConfigSet_Call {
	_c.Call.Return(run)
	return _c
}

// ParseLog provides a mock function with given fields: log
func (_m *CapabilitiesRegistryInterface) ParseLog(log types.Log) (generated.AbigenLog, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseLog")
	}

	var r0 generated.AbigenLog
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (generated.AbigenLog, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) generated.AbigenLog); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(generated.AbigenLog)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_ParseLog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseLog'
type CapabilitiesRegistryInterface_ParseLog_Call struct {
	*mock.Call
}

// ParseLog is a helper method to define mock.On call
//   - log types.Log
func (_e *CapabilitiesRegistryInterface_Expecter) ParseLog(log interface{}) *CapabilitiesRegistryInterface_ParseLog_Call {
	return &CapabilitiesRegistryInterface_ParseLog_Call{Call: _e.mock.On("ParseLog", log)}
}

func (_c *CapabilitiesRegistryInterface_ParseLog_Call) Run(run func(log types.Log)) *CapabilitiesRegistryInterface_ParseLog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_ParseLog_Call) Return(_a0 generated.AbigenLog, _a1 error) *CapabilitiesRegistryInterface_ParseLog_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_ParseLog_Call) RunAndReturn(run func(types.Log) (generated.AbigenLog, error)) *CapabilitiesRegistryInterface_ParseLog_Call {
	_c.Call.Return(run)
	return _c
}

// ParseNodeAdded provides a mock function with given fields: log
func (_m *CapabilitiesRegistryInterface) ParseNodeAdded(log types.Log) (*capabilities_registry.CapabilitiesRegistryNodeAdded, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseNodeAdded")
	}

	var r0 *capabilities_registry.CapabilitiesRegistryNodeAdded
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*capabilities_registry.CapabilitiesRegistryNodeAdded, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *capabilities_registry.CapabilitiesRegistryNodeAdded); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*capabilities_registry.CapabilitiesRegistryNodeAdded)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_ParseNodeAdded_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseNodeAdded'
type CapabilitiesRegistryInterface_ParseNodeAdded_Call struct {
	*mock.Call
}

// ParseNodeAdded is a helper method to define mock.On call
//   - log types.Log
func (_e *CapabilitiesRegistryInterface_Expecter) ParseNodeAdded(log interface{}) *CapabilitiesRegistryInterface_ParseNodeAdded_Call {
	return &CapabilitiesRegistryInterface_ParseNodeAdded_Call{Call: _e.mock.On("ParseNodeAdded", log)}
}

func (_c *CapabilitiesRegistryInterface_ParseNodeAdded_Call) Run(run func(log types.Log)) *CapabilitiesRegistryInterface_ParseNodeAdded_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_ParseNodeAdded_Call) Return(_a0 *capabilities_registry.CapabilitiesRegistryNodeAdded, _a1 error) *CapabilitiesRegistryInterface_ParseNodeAdded_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_ParseNodeAdded_Call) RunAndReturn(run func(types.Log) (*capabilities_registry.CapabilitiesRegistryNodeAdded, error)) *CapabilitiesRegistryInterface_ParseNodeAdded_Call {
	_c.Call.Return(run)
	return _c
}

// ParseNodeOperatorAdded provides a mock function with given fields: log
func (_m *CapabilitiesRegistryInterface) ParseNodeOperatorAdded(log types.Log) (*capabilities_registry.CapabilitiesRegistryNodeOperatorAdded, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseNodeOperatorAdded")
	}

	var r0 *capabilities_registry.CapabilitiesRegistryNodeOperatorAdded
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*capabilities_registry.CapabilitiesRegistryNodeOperatorAdded, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *capabilities_registry.CapabilitiesRegistryNodeOperatorAdded); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*capabilities_registry.CapabilitiesRegistryNodeOperatorAdded)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_ParseNodeOperatorAdded_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseNodeOperatorAdded'
type CapabilitiesRegistryInterface_ParseNodeOperatorAdded_Call struct {
	*mock.Call
}

// ParseNodeOperatorAdded is a helper method to define mock.On call
//   - log types.Log
func (_e *CapabilitiesRegistryInterface_Expecter) ParseNodeOperatorAdded(log interface{}) *CapabilitiesRegistryInterface_ParseNodeOperatorAdded_Call {
	return &CapabilitiesRegistryInterface_ParseNodeOperatorAdded_Call{Call: _e.mock.On("ParseNodeOperatorAdded", log)}
}

func (_c *CapabilitiesRegistryInterface_ParseNodeOperatorAdded_Call) Run(run func(log types.Log)) *CapabilitiesRegistryInterface_ParseNodeOperatorAdded_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_ParseNodeOperatorAdded_Call) Return(_a0 *capabilities_registry.CapabilitiesRegistryNodeOperatorAdded, _a1 error) *CapabilitiesRegistryInterface_ParseNodeOperatorAdded_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_ParseNodeOperatorAdded_Call) RunAndReturn(run func(types.Log) (*capabilities_registry.CapabilitiesRegistryNodeOperatorAdded, error)) *CapabilitiesRegistryInterface_ParseNodeOperatorAdded_Call {
	_c.Call.Return(run)
	return _c
}

// ParseNodeOperatorRemoved provides a mock function with given fields: log
func (_m *CapabilitiesRegistryInterface) ParseNodeOperatorRemoved(log types.Log) (*capabilities_registry.CapabilitiesRegistryNodeOperatorRemoved, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseNodeOperatorRemoved")
	}

	var r0 *capabilities_registry.CapabilitiesRegistryNodeOperatorRemoved
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*capabilities_registry.CapabilitiesRegistryNodeOperatorRemoved, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *capabilities_registry.CapabilitiesRegistryNodeOperatorRemoved); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*capabilities_registry.CapabilitiesRegistryNodeOperatorRemoved)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_ParseNodeOperatorRemoved_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseNodeOperatorRemoved'
type CapabilitiesRegistryInterface_ParseNodeOperatorRemoved_Call struct {
	*mock.Call
}

// ParseNodeOperatorRemoved is a helper method to define mock.On call
//   - log types.Log
func (_e *CapabilitiesRegistryInterface_Expecter) ParseNodeOperatorRemoved(log interface{}) *CapabilitiesRegistryInterface_ParseNodeOperatorRemoved_Call {
	return &CapabilitiesRegistryInterface_ParseNodeOperatorRemoved_Call{Call: _e.mock.On("ParseNodeOperatorRemoved", log)}
}

func (_c *CapabilitiesRegistryInterface_ParseNodeOperatorRemoved_Call) Run(run func(log types.Log)) *CapabilitiesRegistryInterface_ParseNodeOperatorRemoved_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_ParseNodeOperatorRemoved_Call) Return(_a0 *capabilities_registry.CapabilitiesRegistryNodeOperatorRemoved, _a1 error) *CapabilitiesRegistryInterface_ParseNodeOperatorRemoved_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_ParseNodeOperatorRemoved_Call) RunAndReturn(run func(types.Log) (*capabilities_registry.CapabilitiesRegistryNodeOperatorRemoved, error)) *CapabilitiesRegistryInterface_ParseNodeOperatorRemoved_Call {
	_c.Call.Return(run)
	return _c
}

// ParseNodeOperatorUpdated provides a mock function with given fields: log
func (_m *CapabilitiesRegistryInterface) ParseNodeOperatorUpdated(log types.Log) (*capabilities_registry.CapabilitiesRegistryNodeOperatorUpdated, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseNodeOperatorUpdated")
	}

	var r0 *capabilities_registry.CapabilitiesRegistryNodeOperatorUpdated
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*capabilities_registry.CapabilitiesRegistryNodeOperatorUpdated, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *capabilities_registry.CapabilitiesRegistryNodeOperatorUpdated); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*capabilities_registry.CapabilitiesRegistryNodeOperatorUpdated)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_ParseNodeOperatorUpdated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseNodeOperatorUpdated'
type CapabilitiesRegistryInterface_ParseNodeOperatorUpdated_Call struct {
	*mock.Call
}

// ParseNodeOperatorUpdated is a helper method to define mock.On call
//   - log types.Log
func (_e *CapabilitiesRegistryInterface_Expecter) ParseNodeOperatorUpdated(log interface{}) *CapabilitiesRegistryInterface_ParseNodeOperatorUpdated_Call {
	return &CapabilitiesRegistryInterface_ParseNodeOperatorUpdated_Call{Call: _e.mock.On("ParseNodeOperatorUpdated", log)}
}

func (_c *CapabilitiesRegistryInterface_ParseNodeOperatorUpdated_Call) Run(run func(log types.Log)) *CapabilitiesRegistryInterface_ParseNodeOperatorUpdated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_ParseNodeOperatorUpdated_Call) Return(_a0 *capabilities_registry.CapabilitiesRegistryNodeOperatorUpdated, _a1 error) *CapabilitiesRegistryInterface_ParseNodeOperatorUpdated_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_ParseNodeOperatorUpdated_Call) RunAndReturn(run func(types.Log) (*capabilities_registry.CapabilitiesRegistryNodeOperatorUpdated, error)) *CapabilitiesRegistryInterface_ParseNodeOperatorUpdated_Call {
	_c.Call.Return(run)
	return _c
}

// ParseNodeRemoved provides a mock function with given fields: log
func (_m *CapabilitiesRegistryInterface) ParseNodeRemoved(log types.Log) (*capabilities_registry.CapabilitiesRegistryNodeRemoved, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseNodeRemoved")
	}

	var r0 *capabilities_registry.CapabilitiesRegistryNodeRemoved
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*capabilities_registry.CapabilitiesRegistryNodeRemoved, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *capabilities_registry.CapabilitiesRegistryNodeRemoved); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*capabilities_registry.CapabilitiesRegistryNodeRemoved)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_ParseNodeRemoved_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseNodeRemoved'
type CapabilitiesRegistryInterface_ParseNodeRemoved_Call struct {
	*mock.Call
}

// ParseNodeRemoved is a helper method to define mock.On call
//   - log types.Log
func (_e *CapabilitiesRegistryInterface_Expecter) ParseNodeRemoved(log interface{}) *CapabilitiesRegistryInterface_ParseNodeRemoved_Call {
	return &CapabilitiesRegistryInterface_ParseNodeRemoved_Call{Call: _e.mock.On("ParseNodeRemoved", log)}
}

func (_c *CapabilitiesRegistryInterface_ParseNodeRemoved_Call) Run(run func(log types.Log)) *CapabilitiesRegistryInterface_ParseNodeRemoved_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_ParseNodeRemoved_Call) Return(_a0 *capabilities_registry.CapabilitiesRegistryNodeRemoved, _a1 error) *CapabilitiesRegistryInterface_ParseNodeRemoved_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_ParseNodeRemoved_Call) RunAndReturn(run func(types.Log) (*capabilities_registry.CapabilitiesRegistryNodeRemoved, error)) *CapabilitiesRegistryInterface_ParseNodeRemoved_Call {
	_c.Call.Return(run)
	return _c
}

// ParseNodeUpdated provides a mock function with given fields: log
func (_m *CapabilitiesRegistryInterface) ParseNodeUpdated(log types.Log) (*capabilities_registry.CapabilitiesRegistryNodeUpdated, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseNodeUpdated")
	}

	var r0 *capabilities_registry.CapabilitiesRegistryNodeUpdated
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*capabilities_registry.CapabilitiesRegistryNodeUpdated, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *capabilities_registry.CapabilitiesRegistryNodeUpdated); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*capabilities_registry.CapabilitiesRegistryNodeUpdated)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_ParseNodeUpdated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseNodeUpdated'
type CapabilitiesRegistryInterface_ParseNodeUpdated_Call struct {
	*mock.Call
}

// ParseNodeUpdated is a helper method to define mock.On call
//   - log types.Log
func (_e *CapabilitiesRegistryInterface_Expecter) ParseNodeUpdated(log interface{}) *CapabilitiesRegistryInterface_ParseNodeUpdated_Call {
	return &CapabilitiesRegistryInterface_ParseNodeUpdated_Call{Call: _e.mock.On("ParseNodeUpdated", log)}
}

func (_c *CapabilitiesRegistryInterface_ParseNodeUpdated_Call) Run(run func(log types.Log)) *CapabilitiesRegistryInterface_ParseNodeUpdated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_ParseNodeUpdated_Call) Return(_a0 *capabilities_registry.CapabilitiesRegistryNodeUpdated, _a1 error) *CapabilitiesRegistryInterface_ParseNodeUpdated_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_ParseNodeUpdated_Call) RunAndReturn(run func(types.Log) (*capabilities_registry.CapabilitiesRegistryNodeUpdated, error)) *CapabilitiesRegistryInterface_ParseNodeUpdated_Call {
	_c.Call.Return(run)
	return _c
}

// ParseOwnershipTransferRequested provides a mock function with given fields: log
func (_m *CapabilitiesRegistryInterface) ParseOwnershipTransferRequested(log types.Log) (*capabilities_registry.CapabilitiesRegistryOwnershipTransferRequested, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseOwnershipTransferRequested")
	}

	var r0 *capabilities_registry.CapabilitiesRegistryOwnershipTransferRequested
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*capabilities_registry.CapabilitiesRegistryOwnershipTransferRequested, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *capabilities_registry.CapabilitiesRegistryOwnershipTransferRequested); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*capabilities_registry.CapabilitiesRegistryOwnershipTransferRequested)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_ParseOwnershipTransferRequested_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseOwnershipTransferRequested'
type CapabilitiesRegistryInterface_ParseOwnershipTransferRequested_Call struct {
	*mock.Call
}

// ParseOwnershipTransferRequested is a helper method to define mock.On call
//   - log types.Log
func (_e *CapabilitiesRegistryInterface_Expecter) ParseOwnershipTransferRequested(log interface{}) *CapabilitiesRegistryInterface_ParseOwnershipTransferRequested_Call {
	return &CapabilitiesRegistryInterface_ParseOwnershipTransferRequested_Call{Call: _e.mock.On("ParseOwnershipTransferRequested", log)}
}

func (_c *CapabilitiesRegistryInterface_ParseOwnershipTransferRequested_Call) Run(run func(log types.Log)) *CapabilitiesRegistryInterface_ParseOwnershipTransferRequested_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_ParseOwnershipTransferRequested_Call) Return(_a0 *capabilities_registry.CapabilitiesRegistryOwnershipTransferRequested, _a1 error) *CapabilitiesRegistryInterface_ParseOwnershipTransferRequested_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_ParseOwnershipTransferRequested_Call) RunAndReturn(run func(types.Log) (*capabilities_registry.CapabilitiesRegistryOwnershipTransferRequested, error)) *CapabilitiesRegistryInterface_ParseOwnershipTransferRequested_Call {
	_c.Call.Return(run)
	return _c
}

// ParseOwnershipTransferred provides a mock function with given fields: log
func (_m *CapabilitiesRegistryInterface) ParseOwnershipTransferred(log types.Log) (*capabilities_registry.CapabilitiesRegistryOwnershipTransferred, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseOwnershipTransferred")
	}

	var r0 *capabilities_registry.CapabilitiesRegistryOwnershipTransferred
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*capabilities_registry.CapabilitiesRegistryOwnershipTransferred, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *capabilities_registry.CapabilitiesRegistryOwnershipTransferred); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*capabilities_registry.CapabilitiesRegistryOwnershipTransferred)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_ParseOwnershipTransferred_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseOwnershipTransferred'
type CapabilitiesRegistryInterface_ParseOwnershipTransferred_Call struct {
	*mock.Call
}

// ParseOwnershipTransferred is a helper method to define mock.On call
//   - log types.Log
func (_e *CapabilitiesRegistryInterface_Expecter) ParseOwnershipTransferred(log interface{}) *CapabilitiesRegistryInterface_ParseOwnershipTransferred_Call {
	return &CapabilitiesRegistryInterface_ParseOwnershipTransferred_Call{Call: _e.mock.On("ParseOwnershipTransferred", log)}
}

func (_c *CapabilitiesRegistryInterface_ParseOwnershipTransferred_Call) Run(run func(log types.Log)) *CapabilitiesRegistryInterface_ParseOwnershipTransferred_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(types.Log))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_ParseOwnershipTransferred_Call) Return(_a0 *capabilities_registry.CapabilitiesRegistryOwnershipTransferred, _a1 error) *CapabilitiesRegistryInterface_ParseOwnershipTransferred_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_ParseOwnershipTransferred_Call) RunAndReturn(run func(types.Log) (*capabilities_registry.CapabilitiesRegistryOwnershipTransferred, error)) *CapabilitiesRegistryInterface_ParseOwnershipTransferred_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveDONs provides a mock function with given fields: opts, donIds
func (_m *CapabilitiesRegistryInterface) RemoveDONs(opts *bind.TransactOpts, donIds []uint32) (*types.Transaction, error) {
	ret := _m.Called(opts, donIds)

	if len(ret) == 0 {
		panic("no return value specified for RemoveDONs")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []uint32) (*types.Transaction, error)); ok {
		return rf(opts, donIds)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []uint32) *types.Transaction); ok {
		r0 = rf(opts, donIds)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []uint32) error); ok {
		r1 = rf(opts, donIds)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_RemoveDONs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveDONs'
type CapabilitiesRegistryInterface_RemoveDONs_Call struct {
	*mock.Call
}

// RemoveDONs is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - donIds []uint32
func (_e *CapabilitiesRegistryInterface_Expecter) RemoveDONs(opts interface{}, donIds interface{}) *CapabilitiesRegistryInterface_RemoveDONs_Call {
	return &CapabilitiesRegistryInterface_RemoveDONs_Call{Call: _e.mock.On("RemoveDONs", opts, donIds)}
}

func (_c *CapabilitiesRegistryInterface_RemoveDONs_Call) Run(run func(opts *bind.TransactOpts, donIds []uint32)) *CapabilitiesRegistryInterface_RemoveDONs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([]uint32))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_RemoveDONs_Call) Return(_a0 *types.Transaction, _a1 error) *CapabilitiesRegistryInterface_RemoveDONs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_RemoveDONs_Call) RunAndReturn(run func(*bind.TransactOpts, []uint32) (*types.Transaction, error)) *CapabilitiesRegistryInterface_RemoveDONs_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveNodeOperators provides a mock function with given fields: opts, nodeOperatorIds
func (_m *CapabilitiesRegistryInterface) RemoveNodeOperators(opts *bind.TransactOpts, nodeOperatorIds []uint32) (*types.Transaction, error) {
	ret := _m.Called(opts, nodeOperatorIds)

	if len(ret) == 0 {
		panic("no return value specified for RemoveNodeOperators")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []uint32) (*types.Transaction, error)); ok {
		return rf(opts, nodeOperatorIds)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []uint32) *types.Transaction); ok {
		r0 = rf(opts, nodeOperatorIds)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []uint32) error); ok {
		r1 = rf(opts, nodeOperatorIds)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_RemoveNodeOperators_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveNodeOperators'
type CapabilitiesRegistryInterface_RemoveNodeOperators_Call struct {
	*mock.Call
}

// RemoveNodeOperators is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - nodeOperatorIds []uint32
func (_e *CapabilitiesRegistryInterface_Expecter) RemoveNodeOperators(opts interface{}, nodeOperatorIds interface{}) *CapabilitiesRegistryInterface_RemoveNodeOperators_Call {
	return &CapabilitiesRegistryInterface_RemoveNodeOperators_Call{Call: _e.mock.On("RemoveNodeOperators", opts, nodeOperatorIds)}
}

func (_c *CapabilitiesRegistryInterface_RemoveNodeOperators_Call) Run(run func(opts *bind.TransactOpts, nodeOperatorIds []uint32)) *CapabilitiesRegistryInterface_RemoveNodeOperators_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([]uint32))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_RemoveNodeOperators_Call) Return(_a0 *types.Transaction, _a1 error) *CapabilitiesRegistryInterface_RemoveNodeOperators_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_RemoveNodeOperators_Call) RunAndReturn(run func(*bind.TransactOpts, []uint32) (*types.Transaction, error)) *CapabilitiesRegistryInterface_RemoveNodeOperators_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveNodes provides a mock function with given fields: opts, removedNodeP2PIds
func (_m *CapabilitiesRegistryInterface) RemoveNodes(opts *bind.TransactOpts, removedNodeP2PIds [][32]byte) (*types.Transaction, error) {
	ret := _m.Called(opts, removedNodeP2PIds)

	if len(ret) == 0 {
		panic("no return value specified for RemoveNodes")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [][32]byte) (*types.Transaction, error)); ok {
		return rf(opts, removedNodeP2PIds)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [][32]byte) *types.Transaction); ok {
		r0 = rf(opts, removedNodeP2PIds)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, [][32]byte) error); ok {
		r1 = rf(opts, removedNodeP2PIds)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_RemoveNodes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveNodes'
type CapabilitiesRegistryInterface_RemoveNodes_Call struct {
	*mock.Call
}

// RemoveNodes is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - removedNodeP2PIds [][32]byte
func (_e *CapabilitiesRegistryInterface_Expecter) RemoveNodes(opts interface{}, removedNodeP2PIds interface{}) *CapabilitiesRegistryInterface_RemoveNodes_Call {
	return &CapabilitiesRegistryInterface_RemoveNodes_Call{Call: _e.mock.On("RemoveNodes", opts, removedNodeP2PIds)}
}

func (_c *CapabilitiesRegistryInterface_RemoveNodes_Call) Run(run func(opts *bind.TransactOpts, removedNodeP2PIds [][32]byte)) *CapabilitiesRegistryInterface_RemoveNodes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([][32]byte))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_RemoveNodes_Call) Return(_a0 *types.Transaction, _a1 error) *CapabilitiesRegistryInterface_RemoveNodes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_RemoveNodes_Call) RunAndReturn(run func(*bind.TransactOpts, [][32]byte) (*types.Transaction, error)) *CapabilitiesRegistryInterface_RemoveNodes_Call {
	_c.Call.Return(run)
	return _c
}

// TransferOwnership provides a mock function with given fields: opts, to
func (_m *CapabilitiesRegistryInterface) TransferOwnership(opts *bind.TransactOpts, to common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, to)

	if len(ret) == 0 {
		panic("no return value specified for TransferOwnership")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) (*types.Transaction, error)); ok {
		return rf(opts, to)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) *types.Transaction); ok {
		r0 = rf(opts, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address) error); ok {
		r1 = rf(opts, to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_TransferOwnership_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransferOwnership'
type CapabilitiesRegistryInterface_TransferOwnership_Call struct {
	*mock.Call
}

// TransferOwnership is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - to common.Address
func (_e *CapabilitiesRegistryInterface_Expecter) TransferOwnership(opts interface{}, to interface{}) *CapabilitiesRegistryInterface_TransferOwnership_Call {
	return &CapabilitiesRegistryInterface_TransferOwnership_Call{Call: _e.mock.On("TransferOwnership", opts, to)}
}

func (_c *CapabilitiesRegistryInterface_TransferOwnership_Call) Run(run func(opts *bind.TransactOpts, to common.Address)) *CapabilitiesRegistryInterface_TransferOwnership_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].(common.Address))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_TransferOwnership_Call) Return(_a0 *types.Transaction, _a1 error) *CapabilitiesRegistryInterface_TransferOwnership_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_TransferOwnership_Call) RunAndReturn(run func(*bind.TransactOpts, common.Address) (*types.Transaction, error)) *CapabilitiesRegistryInterface_TransferOwnership_Call {
	_c.Call.Return(run)
	return _c
}

// TypeAndVersion provides a mock function with given fields: opts
func (_m *CapabilitiesRegistryInterface) TypeAndVersion(opts *bind.CallOpts) (string, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for TypeAndVersion")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (string, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) string); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_TypeAndVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeAndVersion'
type CapabilitiesRegistryInterface_TypeAndVersion_Call struct {
	*mock.Call
}

// TypeAndVersion is a helper method to define mock.On call
//   - opts *bind.CallOpts
func (_e *CapabilitiesRegistryInterface_Expecter) TypeAndVersion(opts interface{}) *CapabilitiesRegistryInterface_TypeAndVersion_Call {
	return &CapabilitiesRegistryInterface_TypeAndVersion_Call{Call: _e.mock.On("TypeAndVersion", opts)}
}

func (_c *CapabilitiesRegistryInterface_TypeAndVersion_Call) Run(run func(opts *bind.CallOpts)) *CapabilitiesRegistryInterface_TypeAndVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.CallOpts))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_TypeAndVersion_Call) Return(_a0 string, _a1 error) *CapabilitiesRegistryInterface_TypeAndVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_TypeAndVersion_Call) RunAndReturn(run func(*bind.CallOpts) (string, error)) *CapabilitiesRegistryInterface_TypeAndVersion_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateDON provides a mock function with given fields: opts, donId, nodes, capabilityConfigurations, isPublic, f
func (_m *CapabilitiesRegistryInterface) UpdateDON(opts *bind.TransactOpts, donId uint32, nodes [][32]byte, capabilityConfigurations []capabilities_registry.CapabilitiesRegistryCapabilityConfiguration, isPublic bool, f uint8) (*types.Transaction, error) {
	ret := _m.Called(opts, donId, nodes, capabilityConfigurations, isPublic, f)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDON")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, uint32, [][32]byte, []capabilities_registry.CapabilitiesRegistryCapabilityConfiguration, bool, uint8) (*types.Transaction, error)); ok {
		return rf(opts, donId, nodes, capabilityConfigurations, isPublic, f)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, uint32, [][32]byte, []capabilities_registry.CapabilitiesRegistryCapabilityConfiguration, bool, uint8) *types.Transaction); ok {
		r0 = rf(opts, donId, nodes, capabilityConfigurations, isPublic, f)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, uint32, [][32]byte, []capabilities_registry.CapabilitiesRegistryCapabilityConfiguration, bool, uint8) error); ok {
		r1 = rf(opts, donId, nodes, capabilityConfigurations, isPublic, f)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_UpdateDON_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateDON'
type CapabilitiesRegistryInterface_UpdateDON_Call struct {
	*mock.Call
}

// UpdateDON is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - donId uint32
//   - nodes [][32]byte
//   - capabilityConfigurations []capabilities_registry.CapabilitiesRegistryCapabilityConfiguration
//   - isPublic bool
//   - f uint8
func (_e *CapabilitiesRegistryInterface_Expecter) UpdateDON(opts interface{}, donId interface{}, nodes interface{}, capabilityConfigurations interface{}, isPublic interface{}, f interface{}) *CapabilitiesRegistryInterface_UpdateDON_Call {
	return &CapabilitiesRegistryInterface_UpdateDON_Call{Call: _e.mock.On("UpdateDON", opts, donId, nodes, capabilityConfigurations, isPublic, f)}
}

func (_c *CapabilitiesRegistryInterface_UpdateDON_Call) Run(run func(opts *bind.TransactOpts, donId uint32, nodes [][32]byte, capabilityConfigurations []capabilities_registry.CapabilitiesRegistryCapabilityConfiguration, isPublic bool, f uint8)) *CapabilitiesRegistryInterface_UpdateDON_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].(uint32), args[2].([][32]byte), args[3].([]capabilities_registry.CapabilitiesRegistryCapabilityConfiguration), args[4].(bool), args[5].(uint8))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_UpdateDON_Call) Return(_a0 *types.Transaction, _a1 error) *CapabilitiesRegistryInterface_UpdateDON_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_UpdateDON_Call) RunAndReturn(run func(*bind.TransactOpts, uint32, [][32]byte, []capabilities_registry.CapabilitiesRegistryCapabilityConfiguration, bool, uint8) (*types.Transaction, error)) *CapabilitiesRegistryInterface_UpdateDON_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateNodeOperators provides a mock function with given fields: opts, nodeOperatorIds, nodeOperators
func (_m *CapabilitiesRegistryInterface) UpdateNodeOperators(opts *bind.TransactOpts, nodeOperatorIds []uint32, nodeOperators []capabilities_registry.CapabilitiesRegistryNodeOperator) (*types.Transaction, error) {
	ret := _m.Called(opts, nodeOperatorIds, nodeOperators)

	if len(ret) == 0 {
		panic("no return value specified for UpdateNodeOperators")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []uint32, []capabilities_registry.CapabilitiesRegistryNodeOperator) (*types.Transaction, error)); ok {
		return rf(opts, nodeOperatorIds, nodeOperators)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []uint32, []capabilities_registry.CapabilitiesRegistryNodeOperator) *types.Transaction); ok {
		r0 = rf(opts, nodeOperatorIds, nodeOperators)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []uint32, []capabilities_registry.CapabilitiesRegistryNodeOperator) error); ok {
		r1 = rf(opts, nodeOperatorIds, nodeOperators)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_UpdateNodeOperators_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateNodeOperators'
type CapabilitiesRegistryInterface_UpdateNodeOperators_Call struct {
	*mock.Call
}

// UpdateNodeOperators is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - nodeOperatorIds []uint32
//   - nodeOperators []capabilities_registry.CapabilitiesRegistryNodeOperator
func (_e *CapabilitiesRegistryInterface_Expecter) UpdateNodeOperators(opts interface{}, nodeOperatorIds interface{}, nodeOperators interface{}) *CapabilitiesRegistryInterface_UpdateNodeOperators_Call {
	return &CapabilitiesRegistryInterface_UpdateNodeOperators_Call{Call: _e.mock.On("UpdateNodeOperators", opts, nodeOperatorIds, nodeOperators)}
}

func (_c *CapabilitiesRegistryInterface_UpdateNodeOperators_Call) Run(run func(opts *bind.TransactOpts, nodeOperatorIds []uint32, nodeOperators []capabilities_registry.CapabilitiesRegistryNodeOperator)) *CapabilitiesRegistryInterface_UpdateNodeOperators_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([]uint32), args[2].([]capabilities_registry.CapabilitiesRegistryNodeOperator))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_UpdateNodeOperators_Call) Return(_a0 *types.Transaction, _a1 error) *CapabilitiesRegistryInterface_UpdateNodeOperators_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_UpdateNodeOperators_Call) RunAndReturn(run func(*bind.TransactOpts, []uint32, []capabilities_registry.CapabilitiesRegistryNodeOperator) (*types.Transaction, error)) *CapabilitiesRegistryInterface_UpdateNodeOperators_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateNodes provides a mock function with given fields: opts, nodes
func (_m *CapabilitiesRegistryInterface) UpdateNodes(opts *bind.TransactOpts, nodes []capabilities_registry.CapabilitiesRegistryNodeParams) (*types.Transaction, error) {
	ret := _m.Called(opts, nodes)

	if len(ret) == 0 {
		panic("no return value specified for UpdateNodes")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []capabilities_registry.CapabilitiesRegistryNodeParams) (*types.Transaction, error)); ok {
		return rf(opts, nodes)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []capabilities_registry.CapabilitiesRegistryNodeParams) *types.Transaction); ok {
		r0 = rf(opts, nodes)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []capabilities_registry.CapabilitiesRegistryNodeParams) error); ok {
		r1 = rf(opts, nodes)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_UpdateNodes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateNodes'
type CapabilitiesRegistryInterface_UpdateNodes_Call struct {
	*mock.Call
}

// UpdateNodes is a helper method to define mock.On call
//   - opts *bind.TransactOpts
//   - nodes []capabilities_registry.CapabilitiesRegistryNodeParams
func (_e *CapabilitiesRegistryInterface_Expecter) UpdateNodes(opts interface{}, nodes interface{}) *CapabilitiesRegistryInterface_UpdateNodes_Call {
	return &CapabilitiesRegistryInterface_UpdateNodes_Call{Call: _e.mock.On("UpdateNodes", opts, nodes)}
}

func (_c *CapabilitiesRegistryInterface_UpdateNodes_Call) Run(run func(opts *bind.TransactOpts, nodes []capabilities_registry.CapabilitiesRegistryNodeParams)) *CapabilitiesRegistryInterface_UpdateNodes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.TransactOpts), args[1].([]capabilities_registry.CapabilitiesRegistryNodeParams))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_UpdateNodes_Call) Return(_a0 *types.Transaction, _a1 error) *CapabilitiesRegistryInterface_UpdateNodes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_UpdateNodes_Call) RunAndReturn(run func(*bind.TransactOpts, []capabilities_registry.CapabilitiesRegistryNodeParams) (*types.Transaction, error)) *CapabilitiesRegistryInterface_UpdateNodes_Call {
	_c.Call.Return(run)
	return _c
}

// WatchCapabilityConfigured provides a mock function with given fields: opts, sink, hashedCapabilityId
func (_m *CapabilitiesRegistryInterface) WatchCapabilityConfigured(opts *bind.WatchOpts, sink chan<- *capabilities_registry.CapabilitiesRegistryCapabilityConfigured, hashedCapabilityId [][32]byte) (event.Subscription, error) {
	ret := _m.Called(opts, sink, hashedCapabilityId)

	if len(ret) == 0 {
		panic("no return value specified for WatchCapabilityConfigured")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryCapabilityConfigured, [][32]byte) (event.Subscription, error)); ok {
		return rf(opts, sink, hashedCapabilityId)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryCapabilityConfigured, [][32]byte) event.Subscription); ok {
		r0 = rf(opts, sink, hashedCapabilityId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryCapabilityConfigured, [][32]byte) error); ok {
		r1 = rf(opts, sink, hashedCapabilityId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_WatchCapabilityConfigured_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchCapabilityConfigured'
type CapabilitiesRegistryInterface_WatchCapabilityConfigured_Call struct {
	*mock.Call
}

// WatchCapabilityConfigured is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *capabilities_registry.CapabilitiesRegistryCapabilityConfigured
//   - hashedCapabilityId [][32]byte
func (_e *CapabilitiesRegistryInterface_Expecter) WatchCapabilityConfigured(opts interface{}, sink interface{}, hashedCapabilityId interface{}) *CapabilitiesRegistryInterface_WatchCapabilityConfigured_Call {
	return &CapabilitiesRegistryInterface_WatchCapabilityConfigured_Call{Call: _e.mock.On("WatchCapabilityConfigured", opts, sink, hashedCapabilityId)}
}

func (_c *CapabilitiesRegistryInterface_WatchCapabilityConfigured_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *capabilities_registry.CapabilitiesRegistryCapabilityConfigured, hashedCapabilityId [][32]byte)) *CapabilitiesRegistryInterface_WatchCapabilityConfigured_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *capabilities_registry.CapabilitiesRegistryCapabilityConfigured), args[2].([][32]byte))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_WatchCapabilityConfigured_Call) Return(_a0 event.Subscription, _a1 error) *CapabilitiesRegistryInterface_WatchCapabilityConfigured_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_WatchCapabilityConfigured_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryCapabilityConfigured, [][32]byte) (event.Subscription, error)) *CapabilitiesRegistryInterface_WatchCapabilityConfigured_Call {
	_c.Call.Return(run)
	return _c
}

// WatchCapabilityDeprecated provides a mock function with given fields: opts, sink, hashedCapabilityId
func (_m *CapabilitiesRegistryInterface) WatchCapabilityDeprecated(opts *bind.WatchOpts, sink chan<- *capabilities_registry.CapabilitiesRegistryCapabilityDeprecated, hashedCapabilityId [][32]byte) (event.Subscription, error) {
	ret := _m.Called(opts, sink, hashedCapabilityId)

	if len(ret) == 0 {
		panic("no return value specified for WatchCapabilityDeprecated")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryCapabilityDeprecated, [][32]byte) (event.Subscription, error)); ok {
		return rf(opts, sink, hashedCapabilityId)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryCapabilityDeprecated, [][32]byte) event.Subscription); ok {
		r0 = rf(opts, sink, hashedCapabilityId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryCapabilityDeprecated, [][32]byte) error); ok {
		r1 = rf(opts, sink, hashedCapabilityId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_WatchCapabilityDeprecated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchCapabilityDeprecated'
type CapabilitiesRegistryInterface_WatchCapabilityDeprecated_Call struct {
	*mock.Call
}

// WatchCapabilityDeprecated is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *capabilities_registry.CapabilitiesRegistryCapabilityDeprecated
//   - hashedCapabilityId [][32]byte
func (_e *CapabilitiesRegistryInterface_Expecter) WatchCapabilityDeprecated(opts interface{}, sink interface{}, hashedCapabilityId interface{}) *CapabilitiesRegistryInterface_WatchCapabilityDeprecated_Call {
	return &CapabilitiesRegistryInterface_WatchCapabilityDeprecated_Call{Call: _e.mock.On("WatchCapabilityDeprecated", opts, sink, hashedCapabilityId)}
}

func (_c *CapabilitiesRegistryInterface_WatchCapabilityDeprecated_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *capabilities_registry.CapabilitiesRegistryCapabilityDeprecated, hashedCapabilityId [][32]byte)) *CapabilitiesRegistryInterface_WatchCapabilityDeprecated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *capabilities_registry.CapabilitiesRegistryCapabilityDeprecated), args[2].([][32]byte))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_WatchCapabilityDeprecated_Call) Return(_a0 event.Subscription, _a1 error) *CapabilitiesRegistryInterface_WatchCapabilityDeprecated_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_WatchCapabilityDeprecated_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryCapabilityDeprecated, [][32]byte) (event.Subscription, error)) *CapabilitiesRegistryInterface_WatchCapabilityDeprecated_Call {
	_c.Call.Return(run)
	return _c
}

// WatchConfigSet provides a mock function with given fields: opts, sink, donId
func (_m *CapabilitiesRegistryInterface) WatchConfigSet(opts *bind.WatchOpts, sink chan<- *capabilities_registry.CapabilitiesRegistryConfigSet, donId []uint32) (event.Subscription, error) {
	ret := _m.Called(opts, sink, donId)

	if len(ret) == 0 {
		panic("no return value specified for WatchConfigSet")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryConfigSet, []uint32) (event.Subscription, error)); ok {
		return rf(opts, sink, donId)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryConfigSet, []uint32) event.Subscription); ok {
		r0 = rf(opts, sink, donId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryConfigSet, []uint32) error); ok {
		r1 = rf(opts, sink, donId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_WatchConfigSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchConfigSet'
type CapabilitiesRegistryInterface_WatchConfigSet_Call struct {
	*mock.Call
}

// WatchConfigSet is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *capabilities_registry.CapabilitiesRegistryConfigSet
//   - donId []uint32
func (_e *CapabilitiesRegistryInterface_Expecter) WatchConfigSet(opts interface{}, sink interface{}, donId interface{}) *CapabilitiesRegistryInterface_WatchConfigSet_Call {
	return &CapabilitiesRegistryInterface_WatchConfigSet_Call{Call: _e.mock.On("WatchConfigSet", opts, sink, donId)}
}

func (_c *CapabilitiesRegistryInterface_WatchConfigSet_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *capabilities_registry.CapabilitiesRegistryConfigSet, donId []uint32)) *CapabilitiesRegistryInterface_WatchConfigSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *capabilities_registry.CapabilitiesRegistryConfigSet), args[2].([]uint32))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_WatchConfigSet_Call) Return(_a0 event.Subscription, _a1 error) *CapabilitiesRegistryInterface_WatchConfigSet_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_WatchConfigSet_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryConfigSet, []uint32) (event.Subscription, error)) *CapabilitiesRegistryInterface_WatchConfigSet_Call {
	_c.Call.Return(run)
	return _c
}

// WatchNodeAdded provides a mock function with given fields: opts, sink, nodeOperatorId
func (_m *CapabilitiesRegistryInterface) WatchNodeAdded(opts *bind.WatchOpts, sink chan<- *capabilities_registry.CapabilitiesRegistryNodeAdded, nodeOperatorId []uint32) (event.Subscription, error) {
	ret := _m.Called(opts, sink, nodeOperatorId)

	if len(ret) == 0 {
		panic("no return value specified for WatchNodeAdded")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryNodeAdded, []uint32) (event.Subscription, error)); ok {
		return rf(opts, sink, nodeOperatorId)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryNodeAdded, []uint32) event.Subscription); ok {
		r0 = rf(opts, sink, nodeOperatorId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryNodeAdded, []uint32) error); ok {
		r1 = rf(opts, sink, nodeOperatorId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_WatchNodeAdded_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchNodeAdded'
type CapabilitiesRegistryInterface_WatchNodeAdded_Call struct {
	*mock.Call
}

// WatchNodeAdded is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *capabilities_registry.CapabilitiesRegistryNodeAdded
//   - nodeOperatorId []uint32
func (_e *CapabilitiesRegistryInterface_Expecter) WatchNodeAdded(opts interface{}, sink interface{}, nodeOperatorId interface{}) *CapabilitiesRegistryInterface_WatchNodeAdded_Call {
	return &CapabilitiesRegistryInterface_WatchNodeAdded_Call{Call: _e.mock.On("WatchNodeAdded", opts, sink, nodeOperatorId)}
}

func (_c *CapabilitiesRegistryInterface_WatchNodeAdded_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *capabilities_registry.CapabilitiesRegistryNodeAdded, nodeOperatorId []uint32)) *CapabilitiesRegistryInterface_WatchNodeAdded_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *capabilities_registry.CapabilitiesRegistryNodeAdded), args[2].([]uint32))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_WatchNodeAdded_Call) Return(_a0 event.Subscription, _a1 error) *CapabilitiesRegistryInterface_WatchNodeAdded_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_WatchNodeAdded_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryNodeAdded, []uint32) (event.Subscription, error)) *CapabilitiesRegistryInterface_WatchNodeAdded_Call {
	_c.Call.Return(run)
	return _c
}

// WatchNodeOperatorAdded provides a mock function with given fields: opts, sink, nodeOperatorId, admin
func (_m *CapabilitiesRegistryInterface) WatchNodeOperatorAdded(opts *bind.WatchOpts, sink chan<- *capabilities_registry.CapabilitiesRegistryNodeOperatorAdded, nodeOperatorId []uint32, admin []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, nodeOperatorId, admin)

	if len(ret) == 0 {
		panic("no return value specified for WatchNodeOperatorAdded")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryNodeOperatorAdded, []uint32, []common.Address) (event.Subscription, error)); ok {
		return rf(opts, sink, nodeOperatorId, admin)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryNodeOperatorAdded, []uint32, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, nodeOperatorId, admin)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryNodeOperatorAdded, []uint32, []common.Address) error); ok {
		r1 = rf(opts, sink, nodeOperatorId, admin)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_WatchNodeOperatorAdded_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchNodeOperatorAdded'
type CapabilitiesRegistryInterface_WatchNodeOperatorAdded_Call struct {
	*mock.Call
}

// WatchNodeOperatorAdded is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *capabilities_registry.CapabilitiesRegistryNodeOperatorAdded
//   - nodeOperatorId []uint32
//   - admin []common.Address
func (_e *CapabilitiesRegistryInterface_Expecter) WatchNodeOperatorAdded(opts interface{}, sink interface{}, nodeOperatorId interface{}, admin interface{}) *CapabilitiesRegistryInterface_WatchNodeOperatorAdded_Call {
	return &CapabilitiesRegistryInterface_WatchNodeOperatorAdded_Call{Call: _e.mock.On("WatchNodeOperatorAdded", opts, sink, nodeOperatorId, admin)}
}

func (_c *CapabilitiesRegistryInterface_WatchNodeOperatorAdded_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *capabilities_registry.CapabilitiesRegistryNodeOperatorAdded, nodeOperatorId []uint32, admin []common.Address)) *CapabilitiesRegistryInterface_WatchNodeOperatorAdded_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *capabilities_registry.CapabilitiesRegistryNodeOperatorAdded), args[2].([]uint32), args[3].([]common.Address))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_WatchNodeOperatorAdded_Call) Return(_a0 event.Subscription, _a1 error) *CapabilitiesRegistryInterface_WatchNodeOperatorAdded_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_WatchNodeOperatorAdded_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryNodeOperatorAdded, []uint32, []common.Address) (event.Subscription, error)) *CapabilitiesRegistryInterface_WatchNodeOperatorAdded_Call {
	_c.Call.Return(run)
	return _c
}

// WatchNodeOperatorRemoved provides a mock function with given fields: opts, sink, nodeOperatorId
func (_m *CapabilitiesRegistryInterface) WatchNodeOperatorRemoved(opts *bind.WatchOpts, sink chan<- *capabilities_registry.CapabilitiesRegistryNodeOperatorRemoved, nodeOperatorId []uint32) (event.Subscription, error) {
	ret := _m.Called(opts, sink, nodeOperatorId)

	if len(ret) == 0 {
		panic("no return value specified for WatchNodeOperatorRemoved")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryNodeOperatorRemoved, []uint32) (event.Subscription, error)); ok {
		return rf(opts, sink, nodeOperatorId)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryNodeOperatorRemoved, []uint32) event.Subscription); ok {
		r0 = rf(opts, sink, nodeOperatorId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryNodeOperatorRemoved, []uint32) error); ok {
		r1 = rf(opts, sink, nodeOperatorId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_WatchNodeOperatorRemoved_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchNodeOperatorRemoved'
type CapabilitiesRegistryInterface_WatchNodeOperatorRemoved_Call struct {
	*mock.Call
}

// WatchNodeOperatorRemoved is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *capabilities_registry.CapabilitiesRegistryNodeOperatorRemoved
//   - nodeOperatorId []uint32
func (_e *CapabilitiesRegistryInterface_Expecter) WatchNodeOperatorRemoved(opts interface{}, sink interface{}, nodeOperatorId interface{}) *CapabilitiesRegistryInterface_WatchNodeOperatorRemoved_Call {
	return &CapabilitiesRegistryInterface_WatchNodeOperatorRemoved_Call{Call: _e.mock.On("WatchNodeOperatorRemoved", opts, sink, nodeOperatorId)}
}

func (_c *CapabilitiesRegistryInterface_WatchNodeOperatorRemoved_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *capabilities_registry.CapabilitiesRegistryNodeOperatorRemoved, nodeOperatorId []uint32)) *CapabilitiesRegistryInterface_WatchNodeOperatorRemoved_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *capabilities_registry.CapabilitiesRegistryNodeOperatorRemoved), args[2].([]uint32))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_WatchNodeOperatorRemoved_Call) Return(_a0 event.Subscription, _a1 error) *CapabilitiesRegistryInterface_WatchNodeOperatorRemoved_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_WatchNodeOperatorRemoved_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryNodeOperatorRemoved, []uint32) (event.Subscription, error)) *CapabilitiesRegistryInterface_WatchNodeOperatorRemoved_Call {
	_c.Call.Return(run)
	return _c
}

// WatchNodeOperatorUpdated provides a mock function with given fields: opts, sink, nodeOperatorId, admin
func (_m *CapabilitiesRegistryInterface) WatchNodeOperatorUpdated(opts *bind.WatchOpts, sink chan<- *capabilities_registry.CapabilitiesRegistryNodeOperatorUpdated, nodeOperatorId []uint32, admin []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, nodeOperatorId, admin)

	if len(ret) == 0 {
		panic("no return value specified for WatchNodeOperatorUpdated")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryNodeOperatorUpdated, []uint32, []common.Address) (event.Subscription, error)); ok {
		return rf(opts, sink, nodeOperatorId, admin)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryNodeOperatorUpdated, []uint32, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, nodeOperatorId, admin)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryNodeOperatorUpdated, []uint32, []common.Address) error); ok {
		r1 = rf(opts, sink, nodeOperatorId, admin)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_WatchNodeOperatorUpdated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchNodeOperatorUpdated'
type CapabilitiesRegistryInterface_WatchNodeOperatorUpdated_Call struct {
	*mock.Call
}

// WatchNodeOperatorUpdated is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *capabilities_registry.CapabilitiesRegistryNodeOperatorUpdated
//   - nodeOperatorId []uint32
//   - admin []common.Address
func (_e *CapabilitiesRegistryInterface_Expecter) WatchNodeOperatorUpdated(opts interface{}, sink interface{}, nodeOperatorId interface{}, admin interface{}) *CapabilitiesRegistryInterface_WatchNodeOperatorUpdated_Call {
	return &CapabilitiesRegistryInterface_WatchNodeOperatorUpdated_Call{Call: _e.mock.On("WatchNodeOperatorUpdated", opts, sink, nodeOperatorId, admin)}
}

func (_c *CapabilitiesRegistryInterface_WatchNodeOperatorUpdated_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *capabilities_registry.CapabilitiesRegistryNodeOperatorUpdated, nodeOperatorId []uint32, admin []common.Address)) *CapabilitiesRegistryInterface_WatchNodeOperatorUpdated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *capabilities_registry.CapabilitiesRegistryNodeOperatorUpdated), args[2].([]uint32), args[3].([]common.Address))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_WatchNodeOperatorUpdated_Call) Return(_a0 event.Subscription, _a1 error) *CapabilitiesRegistryInterface_WatchNodeOperatorUpdated_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_WatchNodeOperatorUpdated_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryNodeOperatorUpdated, []uint32, []common.Address) (event.Subscription, error)) *CapabilitiesRegistryInterface_WatchNodeOperatorUpdated_Call {
	_c.Call.Return(run)
	return _c
}

// WatchNodeRemoved provides a mock function with given fields: opts, sink
func (_m *CapabilitiesRegistryInterface) WatchNodeRemoved(opts *bind.WatchOpts, sink chan<- *capabilities_registry.CapabilitiesRegistryNodeRemoved) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	if len(ret) == 0 {
		panic("no return value specified for WatchNodeRemoved")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryNodeRemoved) (event.Subscription, error)); ok {
		return rf(opts, sink)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryNodeRemoved) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryNodeRemoved) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_WatchNodeRemoved_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchNodeRemoved'
type CapabilitiesRegistryInterface_WatchNodeRemoved_Call struct {
	*mock.Call
}

// WatchNodeRemoved is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *capabilities_registry.CapabilitiesRegistryNodeRemoved
func (_e *CapabilitiesRegistryInterface_Expecter) WatchNodeRemoved(opts interface{}, sink interface{}) *CapabilitiesRegistryInterface_WatchNodeRemoved_Call {
	return &CapabilitiesRegistryInterface_WatchNodeRemoved_Call{Call: _e.mock.On("WatchNodeRemoved", opts, sink)}
}

func (_c *CapabilitiesRegistryInterface_WatchNodeRemoved_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *capabilities_registry.CapabilitiesRegistryNodeRemoved)) *CapabilitiesRegistryInterface_WatchNodeRemoved_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *capabilities_registry.CapabilitiesRegistryNodeRemoved))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_WatchNodeRemoved_Call) Return(_a0 event.Subscription, _a1 error) *CapabilitiesRegistryInterface_WatchNodeRemoved_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_WatchNodeRemoved_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryNodeRemoved) (event.Subscription, error)) *CapabilitiesRegistryInterface_WatchNodeRemoved_Call {
	_c.Call.Return(run)
	return _c
}

// WatchNodeUpdated provides a mock function with given fields: opts, sink, nodeOperatorId
func (_m *CapabilitiesRegistryInterface) WatchNodeUpdated(opts *bind.WatchOpts, sink chan<- *capabilities_registry.CapabilitiesRegistryNodeUpdated, nodeOperatorId []uint32) (event.Subscription, error) {
	ret := _m.Called(opts, sink, nodeOperatorId)

	if len(ret) == 0 {
		panic("no return value specified for WatchNodeUpdated")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryNodeUpdated, []uint32) (event.Subscription, error)); ok {
		return rf(opts, sink, nodeOperatorId)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryNodeUpdated, []uint32) event.Subscription); ok {
		r0 = rf(opts, sink, nodeOperatorId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryNodeUpdated, []uint32) error); ok {
		r1 = rf(opts, sink, nodeOperatorId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_WatchNodeUpdated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchNodeUpdated'
type CapabilitiesRegistryInterface_WatchNodeUpdated_Call struct {
	*mock.Call
}

// WatchNodeUpdated is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *capabilities_registry.CapabilitiesRegistryNodeUpdated
//   - nodeOperatorId []uint32
func (_e *CapabilitiesRegistryInterface_Expecter) WatchNodeUpdated(opts interface{}, sink interface{}, nodeOperatorId interface{}) *CapabilitiesRegistryInterface_WatchNodeUpdated_Call {
	return &CapabilitiesRegistryInterface_WatchNodeUpdated_Call{Call: _e.mock.On("WatchNodeUpdated", opts, sink, nodeOperatorId)}
}

func (_c *CapabilitiesRegistryInterface_WatchNodeUpdated_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *capabilities_registry.CapabilitiesRegistryNodeUpdated, nodeOperatorId []uint32)) *CapabilitiesRegistryInterface_WatchNodeUpdated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *capabilities_registry.CapabilitiesRegistryNodeUpdated), args[2].([]uint32))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_WatchNodeUpdated_Call) Return(_a0 event.Subscription, _a1 error) *CapabilitiesRegistryInterface_WatchNodeUpdated_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_WatchNodeUpdated_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryNodeUpdated, []uint32) (event.Subscription, error)) *CapabilitiesRegistryInterface_WatchNodeUpdated_Call {
	_c.Call.Return(run)
	return _c
}

// WatchOwnershipTransferRequested provides a mock function with given fields: opts, sink, from, to
func (_m *CapabilitiesRegistryInterface) WatchOwnershipTransferRequested(opts *bind.WatchOpts, sink chan<- *capabilities_registry.CapabilitiesRegistryOwnershipTransferRequested, from []common.Address, to []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, from, to)

	if len(ret) == 0 {
		panic("no return value specified for WatchOwnershipTransferRequested")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryOwnershipTransferRequested, []common.Address, []common.Address) (event.Subscription, error)); ok {
		return rf(opts, sink, from, to)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryOwnershipTransferRequested, []common.Address, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, from, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryOwnershipTransferRequested, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, sink, from, to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_WatchOwnershipTransferRequested_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchOwnershipTransferRequested'
type CapabilitiesRegistryInterface_WatchOwnershipTransferRequested_Call struct {
	*mock.Call
}

// WatchOwnershipTransferRequested is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *capabilities_registry.CapabilitiesRegistryOwnershipTransferRequested
//   - from []common.Address
//   - to []common.Address
func (_e *CapabilitiesRegistryInterface_Expecter) WatchOwnershipTransferRequested(opts interface{}, sink interface{}, from interface{}, to interface{}) *CapabilitiesRegistryInterface_WatchOwnershipTransferRequested_Call {
	return &CapabilitiesRegistryInterface_WatchOwnershipTransferRequested_Call{Call: _e.mock.On("WatchOwnershipTransferRequested", opts, sink, from, to)}
}

func (_c *CapabilitiesRegistryInterface_WatchOwnershipTransferRequested_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *capabilities_registry.CapabilitiesRegistryOwnershipTransferRequested, from []common.Address, to []common.Address)) *CapabilitiesRegistryInterface_WatchOwnershipTransferRequested_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *capabilities_registry.CapabilitiesRegistryOwnershipTransferRequested), args[2].([]common.Address), args[3].([]common.Address))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_WatchOwnershipTransferRequested_Call) Return(_a0 event.Subscription, _a1 error) *CapabilitiesRegistryInterface_WatchOwnershipTransferRequested_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_WatchOwnershipTransferRequested_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryOwnershipTransferRequested, []common.Address, []common.Address) (event.Subscription, error)) *CapabilitiesRegistryInterface_WatchOwnershipTransferRequested_Call {
	_c.Call.Return(run)
	return _c
}

// WatchOwnershipTransferred provides a mock function with given fields: opts, sink, from, to
func (_m *CapabilitiesRegistryInterface) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *capabilities_registry.CapabilitiesRegistryOwnershipTransferred, from []common.Address, to []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, from, to)

	if len(ret) == 0 {
		panic("no return value specified for WatchOwnershipTransferred")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryOwnershipTransferred, []common.Address, []common.Address) (event.Subscription, error)); ok {
		return rf(opts, sink, from, to)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryOwnershipTransferred, []common.Address, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, from, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryOwnershipTransferred, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, sink, from, to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CapabilitiesRegistryInterface_WatchOwnershipTransferred_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchOwnershipTransferred'
type CapabilitiesRegistryInterface_WatchOwnershipTransferred_Call struct {
	*mock.Call
}

// WatchOwnershipTransferred is a helper method to define mock.On call
//   - opts *bind.WatchOpts
//   - sink chan<- *capabilities_registry.CapabilitiesRegistryOwnershipTransferred
//   - from []common.Address
//   - to []common.Address
func (_e *CapabilitiesRegistryInterface_Expecter) WatchOwnershipTransferred(opts interface{}, sink interface{}, from interface{}, to interface{}) *CapabilitiesRegistryInterface_WatchOwnershipTransferred_Call {
	return &CapabilitiesRegistryInterface_WatchOwnershipTransferred_Call{Call: _e.mock.On("WatchOwnershipTransferred", opts, sink, from, to)}
}

func (_c *CapabilitiesRegistryInterface_WatchOwnershipTransferred_Call) Run(run func(opts *bind.WatchOpts, sink chan<- *capabilities_registry.CapabilitiesRegistryOwnershipTransferred, from []common.Address, to []common.Address)) *CapabilitiesRegistryInterface_WatchOwnershipTransferred_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bind.WatchOpts), args[1].(chan<- *capabilities_registry.CapabilitiesRegistryOwnershipTransferred), args[2].([]common.Address), args[3].([]common.Address))
	})
	return _c
}

func (_c *CapabilitiesRegistryInterface_WatchOwnershipTransferred_Call) Return(_a0 event.Subscription, _a1 error) *CapabilitiesRegistryInterface_WatchOwnershipTransferred_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CapabilitiesRegistryInterface_WatchOwnershipTransferred_Call) RunAndReturn(run func(*bind.WatchOpts, chan<- *capabilities_registry.CapabilitiesRegistryOwnershipTransferred, []common.Address, []common.Address) (event.Subscription, error)) *CapabilitiesRegistryInterface_WatchOwnershipTransferred_Call {
	_c.Call.Return(run)
	return _c
}

// NewCapabilitiesRegistryInterface creates a new instance of CapabilitiesRegistryInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCapabilitiesRegistryInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *CapabilitiesRegistryInterface {
	mock := &CapabilitiesRegistryInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
