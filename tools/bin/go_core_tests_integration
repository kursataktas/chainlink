#!/usr/bin/env bash
set -o pipefail
set +e

SCRIPT_PATH=$(dirname "$0"); SCRIPT_PATH=$(eval "cd \"$SCRIPT_PATH\" && pwd")
OUTPUT_FILE=${OUTPUT_FILE:-"./output.txt"}
USE_TEE="${USE_TEE:-true}"

# To allow reuse in CI from other repositories
TOOLS_PATH=${TOOLS_PATH:-"./tools"}

echo "Failed tests and panics: ---------------------"
echo ""
GO_LDFLAGS=$(bash ${TOOLS_PATH}/bin/ldflags)

use_tee() {
  if [ "$USE_TEE" = "true" ]; then
    tee "$@"
  else
    cat > "$@"
  fi
}

echo "Finding and running integration-tagged tests"
# Find all _test.go files with the //go:build integration tag
INTEGRATION_TEST_FILES=$(find . -name '*_test.go' -exec grep -l '//go:build integration' {} +)

if [ -z "$INTEGRATION_TEST_FILES" ]; then
  echo "No integration-tagged tests found."
  exit 0
fi

# Get unique directories of integration-tagged test files
INTEGRATION_TEST_DIRS=$(echo "$INTEGRATION_TEST_FILES" | xargs -n1 dirname | sort -u)

EXITCODE=0

# Run go test for each directory containing integration-tagged tests
for dir in $INTEGRATION_TEST_DIRS; do
  echo "Running tests in directory: $dir"
  go test -json -vet=off -tags integration $TEST_FLAGS -covermode=atomic -coverpkg=./... -coverprofile=coverage.txt "$dir" | use_tee $OUTPUT_FILE
  TEST_EXITCODE=${PIPESTATUS[0]}
  if [[ $TEST_EXITCODE != 0 ]]; then
    EXITCODE=$TEST_EXITCODE
  fi
done


# Assert no known sensitive strings present in test logger output
printf "\n----------------------------------------------\n\n"
echo "Beginning check of output logs for sensitive strings"
$SCRIPT_PATH/scrub_logs $OUTPUT_FILE
if [[ $? != 0 ]]; then
  exit 1
fi

echo "Exit code: $EXITCODE"
if [[ $EXITCODE != 0 ]]; then
  echo "Encountered test failures."
else
  echo "All tests passed!"
fi
echo "go_core_tests exiting with code $EXITCODE"
exit $EXITCODE
